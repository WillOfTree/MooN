# 计算机组成原理

- 适用：软考-中级-软件设计师
- 计算题类型-了解即可
- 其他熟读，选择题能选即可

## 计算机系统概述

### 一、冯诺依曼计算机特点

1. 计算机由运算器、存储器、控制器、输入\输出设备组成
2. 指令和数据可以同时保存在存储器中，可以按**地址访问**存储器
3. 指令和数据均用二进制表示
4. 指令由**操作码**和**地址码**组成
5. 指令在存储器中按顺序存放
6. 机器以**运算器**为中心，IO设备与存储器之间的数据传送通过运算器完成

### 二、按功能划分计算机系统

1. 硬联逻辑级：有计算机内核、门、触发器等逻辑电路组成
2. 微程序级：机器语言是微指令集，由硬件直接执行
3. 传统机器级：机器语言是指令集，由微程序解释执行
4. 操作系统级：
5. 汇编语言级：机器语言是汇编
6. 高级语言级：机器语言是高级语言，编译程序用来翻译
7. 应用语言级：计算机满足某种需求而设计

### 三、寻址

> 已知计算机的字长为32位，存储器的容量为1MB，如果按照直接、半字、字、双字寻址，范围是多少

- 首先明确

  - 公式：容量$\div$ 字长or字or字节

  - 计算机字长位：32位（单位bit）

    半字：计算机位数/2

    字：计算机位数

  - 存储器容量：$1M = 1M/B = 8M/bit(1M/B * 8)$ 

- 按字节寻址（1B = 8bit）

  寻址范围：$1M = 8M/bit\div 8/bit = 1M$​ 

- 按半字寻址（32位计算机，半字：32/2=16bit）

  寻址范围：$1M=8M/bit\div 16/bit = 0.5M =512K$ 

- 按字寻址（32位计算机，字：32bit）

  寻址范围：$1M = 8M/bit\div 32/bit = 0.25M =256K$​​  

### 四、校验码

1. 检错编码：奇偶校验码和循环亢余校验码（CRC）

#### Ⅰ、奇偶校验

1. 奇偶校验就是在信息码的基础上加一位校验码，可以加在信息码前或后面，
2. 奇偶校验只能检验，不能纠错

检验方法

- 奇校验：保证数据得1为奇数

  若原数据有奇数个1，则添加0

  若原数据有偶数个1，则添加1

  > 发送的数据为：1100010，经奇校验后得：1100010 0

- 偶校验：保证数据的1为偶数

#### Ⅱ、循环亢余检验码（CRC）

1. 采用模二运算来构造校验位
2. 数据位为K，校验位为R，则其格式为：K个数据位后有R个校验位

#### Ⅲ、海明码

1. 利用多组的奇偶性来检错和纠错
1. 海明码通过在数据中添加K位校验码，通过扩大码距实现检验和纠错
1. 不光能检测错误，还能纠正错误
1. 设数据位为N位，校验位是K位，则N和K的关系：$2^K-1\ge N+K$ 

> 已知数据信息位为16位，最少应附加_5_位的校验位，才能实现海明码校验

- 数据位为16$\to$ N=16；
- $2^K-1\ge 16+K \to 2^k\ge 16+1+k$​ 
- K为5

### 五、可靠性

1. 可靠性（可用性）是系统从开始运行到某个时间都可正常运行的概率，使用R表示

2. 串联部件可靠性 = 各个部件的可靠性乘积

3. 并联部件可靠性 = 各个（1 - 部件失效率）的乘积

   部件失效率 = $(1-R)^n$​​ ；n为n个部件并联

   部件可靠率 =  $1-(1-R)^n$ 

> 某部件使用在2000台计算机中，运行1000小时后，其中有4台失效，则这部件的可靠性

- $(2000-4)\div2000 = 0.998$ 

## 数据的表示和运算

$bit(比特，位，b)\to B(字节)\to KB\to MB\to GB\to TB\to PB\to EB$

- 1B = 8bit（8位）；

- 字与字节

  字由多个字节组成，字的位位数叫字长，即CPU处理一次二进制数据的长度

  > 64位计算机的字长为64bit

- B（字节）是计算机最常用的单位

- 1个英文占1B；1个中文占2B

### 一、进制转换

1. 二进制转8进制：因为$2^3=8$​，所以，二进制3位转换为1位8进制
2. 二进制转16进制：因为$2^4=16$​​​，所以，二进制4位转换为1位8进制
3. 十六进制符号：H、Ox
4. 八进制：0、1、2、3、4、5、6、7
5. 十六进制：0、1、2、3、4、5、6、7、8、9、A（10）、B（11）、C（12）、D（13）、E（14）、F（15）

|      | 2^{10} | 2^9  | 2^8  | 2^7  | 2^6  | 2^5  | 2^4  | 2^3  | 2^2  | 2^1  | 2^0  |
| ---- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 位   | 11     | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    |
| 值   | 1024   | 512  | 256  | 128  | 64   | 32   | 16   | 8    | 4    | 2    | 1    |

#### Ⅰ、十进制转换

> 十进制数：19，转换为2进制

- $19-2^4=3\to 1000 =2^4$
- $3-2^1=1\to 10 = 2^1$
- $1-2^0=0\to 1=2^0$ 
- $1000+10+1=1011$​​ 

> 十进制数：，转八进制

> 十进制数：，转16进制

#### Ⅱ、二进制转换

> 二进制数：10001.10，转换为十进制

- 位数从0开始，因为$2^0=1$ 
- $1\times2^4+1\times 2^0+1\times 2^{-1}=17.5$​ 

> 二进制数：001 111 000 010，转换为8进制

- 3位为1个8进制数
- 001$\to$ 1；111$\to$ 7；000$\to$ 0；010$\to$ 2
- 所以得八进制数：1702

> 二进制数：101 0110 1110，转换为十六进制

- 4位为1个十六进制数
- $101\to5(1\times2^2+0\times2^1+1\times2^0)$ 
- $0110\to6(1\times2^2+1\times2^1+0\times2^0)$ 
- $1110\to14(1\times2^3+1\times2^2+1\times2^1+0\times2^0)\to E$ 
- 所得十六进制数：56E

#### Ⅲ、八进制转换

> 八进制数：251，转换为二进制

- 2$\to$ 010；5$\to$ 101；1$\to$ 001
- 所以得二进制数：010 101 001

#### Ⅳ、十六进制转换

> 十六进制数：2AC，转换为十进制

- A：10；C：12；
- $2\times16^2+A\times16^1+C\times16^0 = 256+10\times16+12\times1=684$ 

#### Ⅱ、其他进制加减法

十六进制加法：3D + 25 = Ox62

- D+5 = 13+5=18；18超过16需要进位，18-16=2
- 3+2=5，再加上进位1，得6

十六进制减法：3D25 - 05C3 = Ox3762

- 5-3 =2
- 2-C = 2 - 12，需要向前一位借1，所以得16 + 2 - 12 = 6
- D-5，因为已经被借1，得C-5 = 12-5 = 7
- 3-0 =3

#### 例题

> 内存地址从AC000H到C7FFFH，共有_\_\_K个地址单元，若该内存地址按字（16bit）编址，由28片存储器芯片构成，已知构成该内存芯片每片有16K个存储单元，则该芯片每个存储单元存储__位

1. 共有多少地址单元

   - AC000H、C7FFFH都是十六进制数

     A=10、B=11、C=12；7-C=7-12

     C7FFFH - AC000H = 1BFFFH = 0001 1100 0000 0000 0000 B

   - 总容量：0001 1100 0000 0000 0000 B + 1 = 0001 1100 0000 0000 0001 B

   - 换算：0001 1100 0000 0000 0000B = 0001 1100 00 KB

   - 0001 1100 00 KB = 112（转换为10进制）

     共有112个地址单元

2. 每个存储单元存储多少位

   公式：$\frac{总的位数}{总的存储单元}$ 

   $总的位数=地址单元 \times 地址编址 = 112K\times 16bit$

   $总的存储单元 = 28\times 16K$

   得：$\frac{112K\times 16bit}{28\times 16K} = 6b$​​ 

> 某字长32位的计算机，磁盘容量位300GB，物理块大小1MB，那么位视图为___字

- 单位转换：$300GB = 300G\times1024MB=307200MB$​ 
- 物理块个数：$307200\div1MB = 307200个$ 
- 位视图大小：$307200\div 32位 = 9600$​ 

> 假设2K$\times$4位的存储器芯片组成16K$\times$8位的存储器（地址单元从0000H - 3FFFH）则地址单元0B1FH所在的芯片最小编号为

- $(16K\times 8)\div(2K\times 8) = 16$​片存储器

- 地址大小

  $3FFFH-0000H+1 = 4000H\to $​ 存储器的总容量

  $4000H\to 4\times16^3+0\times16^2 +0\times16^1+0\times16^0=16384 bit$ 

  $16384\div16 = 1024$​（每一块存取器的大小）

> 地址编码从80000H到BFFFFH且按字节编址的内存容量为（）KB，使用16K*4bit的存储器，需要几片

- BFFFFH-80000H = 3FFFFH = 0011 1111 1111 1111 1111B

- 总容量：0011 1111 1111 1111 1111B + 1= 0010 0000 0000 0000 0000B

- 换算：$010 0000 0000 0000 0000B =2^{18}B=2^8KB=256KB$ （只有单个1才可以数位数）

- 总容量/存储器容量 = 需要的内存个数

  $(256KB\times 8bit) \div (16KB\times4bit) = 32片$ 

### 二、真值和机器数

1. 原码：

    内存中存储**正数**使用原码（正数三码相等）

2. 补码：符号位不变，其余位取反后+1

    - 内存中存储**负数**使用补码
    - 补码可以简化计算机运算部件的设计
    - **补码的 +0 与 -0 表示相同**
    - n位补码（包含符号位$n-1$数据位），可直接表示数值：$-2^{n-1}到 2^{n-1}-1$  

3. 反码：符号位不变，其他位取反

    **反码的“0” 有2种表示**：+0 = 0000；-0 = 1111

4. 移码：

    只能表示整数

    **移码的 +0 与 -0 表示相同**

> 例： 计算（-1）的补码、反码、补码

- 原码：$1=0 0001；-1 = 1 0001$ ；

    原码保存负数，最左侧1位为符号位，符号位1，表示负数

- 反码：11110

    除符号位外都取反

- 补码：11111

    补码 = 反码 + 1；

    补码 = ^原码 + 1；

- 移码：01111

    补码的基础上，对符号位进行取反

> 若“2x”的补码是90H，则x的真值是 -556

- 判断符号位：0（原码、反码、补码不变）；1（补码）

    90H = 1001 0000（H是十六进制单位）

- 原码为： 1 111 0000

  1 110 1111（最高位不变，其余位取反）
  
  1 110 1111+1 = 1 111 0000
  
- 1110 0000 = -112；

- 2x=-112；x=-56

### 三、定点数的表示和运算

1. 小数点位固定的数
1. 定点数表示的数，分为整数、定点数小数
1. 定点数表示法中，小数点占一个存储位

### 四、浮点数的表示和运算

1. 小数点位不固定的数

2. 浮点数使用阶码、尾数表示

3. 浮点数相加首先应统一阶码

    例如：$1\times10^{-2}+2\times10^{-1} = 0.21$​ 

    文字描述：小阶向大阶对齐，尾数向右移动n位

4. 浮点数的格式：$\fbox{阶符|码阶|数符|尾数}$​​​ 

    $N =2M\times R$  （$M：阶码；R^e：尾数$ ）

    - 阶码：表示的数范围，阶码越大，表示的数范围大
    - 尾数：表示数的精度，位数越大，精度高

    > 例如：1 0001 0 0000000001；其中1为阶符，0001为补码（阶符），0为数符，0000000001为原码（尾数）

    - 阶码：0001 = 1110 + 1 = 1111；

    - 阶符：1表示负数，0表示正数

        1 1111 = -15

    - 尾数：$000 000 000 1 = 2^{10}$

    - 数符：0表示负数，1表示正数（因为尾数是小数，所以与其他不同）

        0 $000 000 000 1 = 2^{-10}$

    - 结果为：$2^{-15}\times 2^{-10}$ 

        

5. 浮点数通常表示为：$N =M\times R^e$ 

    M：尾数（浮点数表示的精度）；R：基数；e：阶码（表示浮点数表示范围）；

    例：$10.3\times 10^5 = 1030000$

### 七、算数逻辑单元

#### Ⅰ、常用逻辑运算符

- 情况一，A B同真同假；&&与 || 的结果与AB相同

    例：AB为真（1）则；A&&B=1

    例：AB为假（0）则；A || B=0

- 情况二，AB一真一假；&&与 || 的结果与符号相同（&&为0，||为1）

    例：AB一真一假；A&&B=0

    例：AB一真一假；A||B=1 

```c
&& //两个数同时为真才为真
|| //有1个为真即为真
！ // 取反
^  // 异或操作，相同为0不同为1
```

#### Ⅱ、短路求值

- &&为0，||为1

- 只看最左边第一个表达式的结果，表达式结果与逻辑运算符相同退出运算

    情况1：&&（0），左边第一个表达式为0，退出运算

    情况2：||（1），左边第一个表达式为1，退出运算

```c
// &&（0）逻辑与，如果第一个运算为假（0），退出运算（第2个运算短路）
(a = 0) && (b = 1); // a=0假， 退出运算(不执行b=1)
(a = 1) && (b = 1); // a=1真， 继续运算（执行b=1)

// || 逻辑或，如果第一个为真（1），退出运算（第2个运算短路）
(a = 1) || (b = 1); // a=1真， b=1（短路）
(a = 0) || (b = 1); // a=0, b=1, 先运行a=0,假，再运行b=1真，其整体结果为真，a,b都运行
```

## 存储器层次结构

### 一、基本概念

1. 相连存储器是按内容访问的存储器
2. 按寻址方式划分
    - 随机存储器（RAM）
    - 顺序存储器（SAM）
    - 直接存储器（DAM）
3. 串行访问存储器：对存储器进行访问时要按照物理位置的先后顺序依次访问
4. 计算机采用分层存储体系主要目的是：解决存储容量、价格和速度之间的矛盾
5. 常用的虚拟内存使用**主存-辅存**组成
6. 计算机系统的主存主要是由DRAM（动态随机存储器）构成
7. CACHE主要是由SRAM构成

### 二、半导体随机存储器

#### Ⅰ、SRAM存储器

1. 6晶体管存储
2. 读写速度快、集成率高、功耗低等优点
3. 适合缓存和高速缓存等快速反应的场合

#### Ⅱ、DRAM存储器

1. 单电容结构存储
2. 存储单元元件少，集成率比SRAM高，读写速度比SRAM慢
3. 需要更高的功能，动态周期性刷新
4. 计算机主存主要由DRAM构成

#### Ⅲ、只读存储器ROM

1. 掩膜型只读存储器（MROM）：制造时写入，之后只能读取；常见BIOS

2. 可编程只读存储器（PROM）：一次性写入存储器

3. 可擦除可编程只读存储器（EPROM）：使用紫外线擦除信息

4. 电可擦除可编程只读存储器（EEPROM）：使用电擦除

5. 快速擦除读写存储器（Flash Memory）：闪存

    掉电后信息不丢失，属于非易失存储器

    以块为单位进行删除

    在嵌入式系统中可以使用flash替代ROM存储

6. 光盘（CDROM）

### 四、高速缓存存储器Cache

1. 空间局部性：访问到一个内容，也可能访问它周围的内容
2. 时间局部性：访问顺序
3. Cache是主存的一个复制，并没有扩大主存，cache的内容是主存的拷贝
4. cache的地址映射是硬件自动完成的，并不是操作系统实现的
5. cache即可存放数据也可存放程序
6. cache的设计思想是在合理成本下提高命中率

主存地址映射方法

- 直接映像：地址变换简单，灵活性差

- 相联存储器：按内容访问

- 全相联映像：主存的任意一块可转入cache的任意位置，只有装满才需要替换

    **发生块冲突次数最小** 

- 组相联映像：组间采用直接映像，组内采用全相联映像


替换算法

1. 随机替换算法（RAND）：随机产生一个替换的块号，进行替换
2. 先进先出（FIFO）：最先进入的数据弹出
3. 近期最少使用（LRU）：近期最少使用的Cache替换出去
4. 优化替换（OPT）：先执行一次程序，统计cache使用情况，然后在替换

### 六、外存储器

1. 格式化容量：$面数*（磁道数/面数）*（扇区数/道）*（字节数/扇区数）$
2. 非格式化容量：$面数*（磁道数/面数）*内圆周长*最大位密度$​ 
3. 移臂调度算法中，**先来先服务**和**最短寻找时间优先**算法非随时改变移动臂的而运动方向

> 磁盘块的大小为1KB，每个块号占3B，

- 物理磁盘可以存放：1024 B / 3B = 341个块
- 一级索引文件最大长度：341KB
- 二级索引文件最大长度：341 * 341 = 116281KB 
- 根索引采用一级索引文件最大长度：1024B(1KB) * 341
- 根索引采用二级索引文件最大长度：1024B * 341 *341 

> 磁盘有100个磁道，磁头从一个磁道移动到另一个磁道需要6ms，文件在磁盘上非连续存放，逻辑上相邻数据块的平均距离为10个磁道，每个旋转延迟时间及传输时间分别为100ms和20ms，读取100块文件需要_ms

- 每块旋转延迟共：100+20 = 120ms
- 读取一个数据块：$10磁道\times 6ms = 60ms$ 
- 访问一个数据数据块需要时间：120 + 60 = 180ms
- 读取100块需要：180 * 100 = 18000

## 指令系统

### 一、指令格式

1. 指令格式：$\fbox{操作码|地址码}$​ 
2. 操作码：定长操作码、不定长操作码；进行加减乘除等操作
3. 地址码：要操作地址

### 二、寻址方式

1. 立即寻址：操作数作为指令的一部分直接写在指令中（直接指出操作数本身地址方式）、

    > mov R1,#45（将数45传递到寄存器R1中）

    - 45是操作数，在指令中

2. 直接寻址：操作数放在内存中，将指令地址存入PC中

3. 寄存器寻址：操作数都存放在寄存器中

    > mov R1,#45（将数45传递到寄存器R1中）

    - 关键字寄存器

4. 寄存器间接寻址：SI、DI、BX、BP这四个寄存器中

5. 寄存器相对寻址：偏移量

6. 基址加变址寻址方式：基址寄存器

7. 相对基址加变址方式：基址寄存器+偏移量

### 三、CISC与RISC

1. RISC：精简指令集

    - 指令长度固定、指令少、寻址方式少

    - 少于100条指令数目

    - 采用流水线技术

        流水技术包括超流水线、超标量和超长指令字。

    - 只有存数store（取数load）指令能访问存储器、其他指令都在寄存器完成

    - 控制器采用**组合逻辑控制**

    - CPU中有多个通用寄存器，比CISC多

    - 采用硬布线逻辑执行指令

2. CISC：复杂指令集

    - 指令系统复杂
    - 寻址方式多、指令长度不固定
    - CISC采用微程序控制

3. RISC比CISC更能提高计算机的运行速度

4. RISC比CISC更便于设计、可降低成本，提高可靠性

5. RISC更能有效支持高级语言

### 四、指令流水线

1. 指令控制方式：顺序方式、重叠方式、流水方式
1. 最大吞吐率取决于流水线中最慢的所需时间
1. 如果流水中断，加速度会明显下降
1. 流水方式：是并发和并行性嵌入计算机系统的一种形式
1. 流水线方式可同时执行多条指令
1. 流水线方式提高了各部件的利用率
1. 流水线方式提高了系统吞吐率

#### Ⅰ、流水线

- **流水操作周期**：取值、分析、执行最长的时间

- **1条指令执行时间** = 取值时间 + 分析时间 + 执行时间

- **流水线N条指令需要多少时间：** 

  $1条指令执行时间+(指令条数-1)\times 流水操作周期$ 

> 指令流水的取指2ns、分析2ns、执行1ns，流水周期是多少，100条执行指令执行完毕需要多少时间

- 流水操作周期：2ns
- 流水线100条指令需要时间：$(1ns+2ns+2ns) + (100 -1)\times 2 = 203$ 

#### Ⅱ、流水吞吐率

- 流水吞吐率（TP）：单位时间内流水线完成的任务数量、或输出结果
- 公式：$TP = \frac{指令条数}{流水线执行时间}$​ 
- 流水线执行时间：流水线n条指令需要时间

#### Ⅲ、流水加速比

- 流水线加速比：$\frac{不使用流水线执行时间}{使用流水线执行时间}$ 

> 指令流水的取指2ns、分析2ns、执行1ns，执行100条，不使用流水执行时间

- 指令执行时间：$(2ns+2ns+1ns)\times 100$​ 

#### Ⅱ、Flynn分类法

| 体系结构             | 结构                              | 关键特征                         | 代表                                   |
| -------------------- | --------------------------------- | -------------------------------- | -------------------------------------- |
| 单指令流单数据流SISD | 控制部分：1 处理器：1 主板模块：1 |                                  | 单处理器系统                           |
| 单指令流多数据流SIMD | 控制部分：1 处理器：n 主板模块：n | 处理器以异步的形式执行同一条指令 | 并列处理器、阵列处理机、超级向量处理机 |
| 多指令单数据流MISD   | 控制部分：n 处理器：1 主板模块：n | 不可能实现                       | 只有理论意义，不存在                   |
| 多指令多数据流MIMD   | 控制部分：n 处理器：n 主板模块：n | 业务指令同时进行                 | 多处理机系统                           |



## 中央处理器

运算器中的寄存器

1. 商乘寄存器（MQ）：乘除运算中，用于存放操作数和运算结果
2. 算数逻辑单元（ALU）：数算和逻辑运算
   - 其部件：加法器、加法器、乘法器等
3. 累加寄存器（ACC、AC）：为**ALU**执行算数运算or逻辑运算，提供数据、保存/暂存运算结果
4. 通用寄存器（X）：存放操作数
5. 数据缓存寄存器（DR）：数据缓存
6. 状态条件寄存器（PSW）：保存指令运行的标志

控制器中的寄存器

1. **程序寄存器（PC）**：具有寄存信息和计数功能

    - 为实现程序指令顺序执行，CPU中PC寄存器自动加1

    - 跟踪指令地址

    - 在一个指令周期内，从内存中读取指令操作码，将PC中的内容送到地址总线上

      寄存信息：当前执行的下一条指令

2. 指令寄存器（IR）：当前正在执行指令

    - 指令寄存器的位数取决于：指令字长

    - 对用户完全透明

    - 操作码、地址码都存入此

3. 控制器（CU）：给出控制信号（控制器）

    - 不仅要保证指令正确执行，还要能处理异常事件

4. 地址寄存器（AR）：保存CPU当前访问的地址

5. 指令译码器（ID）：对操作码进行分析、指令译码（主要功能指令译码）

6. 其他存储器：

    - 存储器数据寄存器（MDR）

    - 存储器地址寄存器（MAR）

> CPU如何区分数据还是指令：

- 指令周期不同阶段

- CPU完成一个指令可以分为取指令阶段和执行阶段

  取指令阶段：CPU从存储器中取出指令

  执行阶段：CPU从存储器中取出数据

## 总线

- 总线考的偏，理解即可

### 一、总线基本概念

1. PCI总线是并行内总线，SCSI总线是并行外总线
2. 总线复用：减少总线中信号线的数量
3. 在系统中使用总线结构：减少信息传输线的数量

> 总线宽度为 32bit，时钟频率为 200MHz，总线上每5个时钟传送一个32bit的字，总线带宽为__MB/s

- 公式：$时钟频率MHz\div 时钟个数\times(总线宽度bit\div 8) $
- $200MHz\div 5 \times (32bit\div 8) = 160MB/s $ 

### 二、总线分类

1. 片内总线：CPU内部总线，连接寄存器

2. 计算机中采用总线结构，便于实现系统的积木化构造，减少信息传输线的数量

3. 系统总线：计算机内部的总线，连接CPU、主存、硬盘

    按照传输内容不同分类（三总线结构的计算机总线）

    - 数据总线
    - 地址总线
    - 控制总线

## I/O系统

### 一、中断

1. 中断向量提供**中断服务程序入口地址**
2. 为了实现多级中断嵌套，使用堆栈保护断点和现场
3. 中断响应时间：发出中断请求开始，到进入中断服务程序
4. 保存现场的目的：返回继续执行程序
5. I/O设备的中断时可屏蔽中断，电源断电时不可屏蔽中断
6. 直接存储器存储：CPU只需要在开始和结束时少量处理，无需干预数据传输过程
7. I/O接口与打印设备间的交换是异步传输方式
8. 管理键盘最适合采用的I/O控制方式是中断方式

### 二、IO控制方式

1. 程序查询方式：由CPU直接控制
    - CPU和IO设备只能串行工作
    - CPU发出I/O命令后需要不断轮询
    - CPU先查询外设状态，再交换数据
2. 中断驱动方式：
    - IO设备主动报告
    - IO设备和cpu可用并行工作
    - 传输单位是字
3. 直接存储器存取方式（DMA）：

    - 这是**主存**与**外设**的信息交换、不需要CPU进行干预，完全由硬件完成的I/O操作方式
    - cpu在一个总线周期结束后响应DMA请求，
    - 使用DMA传送数据，每传送1个数据就要占用一个存储周期
    - CPU和IO设备可以并行工作
    - 读写设备的单位是块，不是字
