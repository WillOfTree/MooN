# 软考-软件工程师

- 适用于：软考-中级-软件工程师

- 未包含内容

  - 数据结构
  - 计算机组成原理
  - 计算机网络

- 考试内容

  <img src="D:\windows\Pictures\4ba10322a7bd469a8cef6f2f9f82972b~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.png" style="zoom:100%;" />

## 程序设计语言

1. 低级语言：机器语言、汇编语言
2. 高级语言：C/C++
3. 程序设计语言的定义：语法、语义、语用、语境
4. 程序设计语言必须有类型：
    1. 为数据合理分配存储单元
    2. 规定数据的取值范围、能够进行的运算
    3. 对表达式求值进行合法检测

### 一、各个语言的特点

1. Fortran：科学计算
2. Pascal：为教学而开发，
3. C：指针操作能力强
4. Lisp：函数式语言，符号处理，人工智能
5. C++：面向对像
6. Java：面向对像，中间代码，跨平台
7. C#：面向对象，中间代码，Net
8. Prolog：逻辑推理，数据库和专家系统

## 软件工程

1. 配置数据库一般包括：开发库、受控库、产品库
2. 对于大多数通用程序设计语言，用上下文无关描述其语法
3. 对高级语言编译过程中，使用符号表来记录源程序中各个符号的必要信息
4. 对高级语言进行编译或解释的过程可以分为多个阶段，解释方式不包含目标代码生成
5. 对于高级语言编译或解释过程中需要进行语法分析

    - 递归子进程分析属于自上而下
    - 分配寄存器属于目标代码生成阶段
    - 中间代码可以使用栈和队列表示，好处是有利于进行与机器无关的优化处理
    - 堆区一般进行函数调用和返回时由系统进行控制和管理
6. 反编译通常不能把可执行文件还原成源代码，只能转换成等价的汇编程序
7. 基本COCOMO软件成本估算模型是一种静态单变量模型，用于对整个软件系统进行估算

### 一、软件工程

1. 模块划分不是软件工程模型的内容

#### Ⅰ、能力成熟度模型CMM

1. 初始级：软件工程是杂乱无章的，软件成功完全依赖个人
2. 可重复级：建立了**基本的**项目管理和实践来跟踪项目费用、进度和功能
3. 已定义级：管理和工程两方面软件几经**文档化**和**标准化**
4. 已管理级：（**关键字管理**）
   - 制定了软件和产品质量的详细度量标准
   - 对软件和产品都有定量的理解和控制
   - 关注产品和过程质量
5. 优化级：加强了定量分析，通过反馈不断更新（关键字更新，改进）

#### Ⅱ、能力成熟度模型CMMI

1. 阶段试模型
   - 初始级：不可预测且不可控
   - 已管理：为项目服务
   - 已定义：为组织服务
   - 定量管理：过程已度量和控制
   - 优化的：集中于过程改进
2. 连续式模型
   - CL0未完成级：过程未执行或未达到CL1的目标
   - CL1已执行级：关键字：输入输出
   - CL2已管理：
   - CL3已定义：关键字：标准化
   - CL4定量管理：
   - CL5优化级：关键字：优化、改进、量化（统计学）手段

### 二、软件工程模型

1. 瀑布模型
   - 大规模系统
   - 明确需求：具备开发经验、替换原有系统、系统功能有清晰定义、项目初期对软件需求有准确全面的认识、需求被清晰定义
   - 容易理解，管理成本低
   - 瀑布模型难以适应需求突然变化
   - 强调开发阶段的早期计划

2. V模型
   - 瀑布模型的变体
   - V模型描述了质量保证和沟通、建模相关活动之间关系
   - V模型与瀑布模型同时出现，一般选择瀑布模型

3. 增量模型
   - 第一个可交付版本时间少、成本少（可快速构造可运行版本）
   - 是一种适用于商业产品创新的版本
   - 适合商业产品开发
   - 最高级优先功能首先交付
   - 用户需求要清晰，不然会影响开发进度
   - 开发由增量表示的小系统所承受的风险低
   - 增量模型的管理、进度、配置的复杂性高
   
4. 演化模型
   - 系统功能在使用过程中经常改变
   - 可以尽快的使用

5. 原型模型
   - 有效的捕获系统需求（用户需求不明确）
   - 用户需求经常变化
   - 系统规模不是很大、不是很复杂

6. 螺旋模型
   - 特点：风险评估、适合大规模软件

7. 喷泉模型
   - 以用户需求为动力、以对象为驱动（面向对象的开发方法）

   - 开发过程具有迭代性和无间隙性

     各软件开发活动（如分析、设计、编码）之间没有间隙

   - 克服了瀑布模型不支持软件重用和多项开发活动集成的局限性

8. 统一过程模型（UP）

### 三、敏捷开发

1. 极限编程（XP）

   4大价值观：沟通、简单性、反馈、勇气

   5个原则：快速反馈、简单假设、逐步修改、提倡修改、优质工作

   12个最佳实践：

   - 计划游戏：快速制定计划
   - 隐喻：找到合适的比喻传达信息
   - 小型发布：系统设计尽可能早交付 
   - 简单设计：只处理当前需求、使设计保持简单
   - 测试先行：先写测试代码、再写程序
   - 重构：重新审视需求和设计
   - 结对编程：
     - 支持共同代码拥有和共同对系统负责
     - 非正式的代码审核
     - 代码质量更高
   - 集体代码所有制
   - 持续集成：可以按日或小时为客户提供可运行版本

2. 水晶法（crystal）：不同的项目需要不同的策略约定和方法

3. 并列争求法（scrum）：使用迭代方法

4. 自适应软件开发（ASD）：

5. 敏捷统一过程（AUP）

   - 在大型上连续、在小型上迭代
   - 采用经典的UP阶段性活动，即初始化、精化、构件、转换

### 四、系统设计

#### Ⅰ、概要设计

1. 设计软件总体结构
   - 划分功能模块、将系统划分为多个子系统
   - 确定模块之间的调用关系
   - 确定模块之间的接口
   - 评价模块质量
2. 数据结构和数据库设计
   - 数据结构设计
   - 数据库设计：概念设计、逻辑设计、物理设计
3. 编写概要设计文档：
4. 评审：

#### Ⅱ、详细设计

1. 对模块进行详细算法设计
2. 对模块内的数据结构进行设计
3. 对数据库进行物理设计

### 五、系统测试

1. 软件产品的 Alpha 测试和 Beta 测试属于（ 确认测试）。
2. 软件测试是为了发现软件中存在的错误，不存的错误无法发现
3. 软件测试是在开发的每一个阶段（并不是从编码阶段开始）
4. 成功的测试是发现一个尚未发现的错误
5. 测试用例不仅要设计有效合理输入，也要包含不合理，失效输入
6. 系统测试阶段的测试目标来自需求分析阶段
7. 在设计测试用例时应考虑数据输入和预期输出结构
8. 软件测试的目的不是为了证明软件的正确性
9. 单元测试
   - 模块接口
   - 局部数据：是否使用了尚未赋值的变量
   - 重要的执行路径
   - 出错处理
   - 边界条件
10. 集成测试
    - 自顶向下的集成测试：不需要编写驱动程序，需要桩程序
    - 自底向上的集成测试：不需要编写桩程序，需要驱动程序
    - 回归测试：改正现有BUG，会出现新的BUG
    - 冒烟测试
    - 单元测试：对模块进行测试

### 六、测试方法

1. 静态测试：人工测试、计算机辅助静态
2. 动态测试：分为黑盒测试和白盒测试

#### Ⅰ、黑盒测试（功能测试）

1. 不用知道软件内部是如何实现的
2. 黑河测试功能
   1. 等价内容划分
   2. 边界值分析
   3. 错误猜测
   4. 因果图
3. 如何判断测试用例好坏，测试用例应包含一个正确的结果一个错误的结果
4. **合理**与**不合理**的输入应当在黑盒测试中进行处理。

#### Ⅱ、白盒测试

1. 使用白盒测试应根据程序内部结构和指定的覆盖标准确定测试数据

2. 语句覆盖是最弱的覆盖准则，路径覆盖是最强的覆盖准则

3. 逻辑覆盖

   - 语句覆盖：只计算语句（长方形）的分支

     最少语句覆盖，最少为1个

   - 判定覆盖（分支覆盖法）：包含所有判定框（菱形框）

   - 条件覆盖：菱形框中的条件都满足1次

   - 条件/判断组合覆盖：

   - 条件组合覆盖：

   - 路径覆盖：包含所有路径

   - 注意循环语句的表示，循环语句不算一条路径

     <img src="assets/2024-05-19 142738.png" style="zoom:75%;" />

4. 循环覆盖

5. 基本路径测试

#### Ⅲ、MCCabe

1. McCabe度量法计算程序环路复杂度：$V = m-n+2$ 
2. M：图中边的个数
3. N：图中节点个数

### 七、运行和维护知识

#### Ⅰ、系统维护

1. 系统可维护性评价指标：可理解性、可测试性、可修改性

2. 提高软件的可维护性，不是在维护阶段就开始的、各个时期的关键目标

3. 可维护性是衡量软件质量的一个重要特征

4. 文档对软件的可维护性非常重要

5. 编写高质量文档可以提高软件开发质量

6. 文档也是软件产品的一部分，没有文档不能称为软件

7. 软件文档的编制在软件开发工作中占有突出地位和相当大的工作量

8. 高质量文档对于软件产品的效益有重要意义

9. 系统维护：硬件维护、软件维护、数据维护

10. 软件维护包括

    - 正确性维护：改正开发期间没有发现的BUG、防错性程序设计

    - 适应性维护：关键字：适应

      由于外部市场环境和管理需求的变化对现有软件系统提出新的需求

    - 完善下维护：扩充功能和完善功能、提高性能（没有适应关键字的添加功能）

    - 预防性维护：关键字：预防

11. 可靠性：系统在给定的时间内、条件下无失效运行的概率

    公式：MTTF/（1+MTTF）

12. 可用性：系统正确运行的概率

    公式：MTBF/（1+MTBF）

13. 可维护性：完成维护的概率

14. 沟通路径：无向图

#### Ⅱ、软件项目估算

1. 基本cocomo模型：静态单变量模型
2. 中级cocomo模型：静态多变量模型
3. 详细cocomo模型： 子模型
4. cocomo Ⅱ模型：分为三个阶段模型
5. cocomo Ⅱ模型在层次结构中有3种不同的规模
   - 应用组装模型-对象点
   - 早期设计阶段模型-功能点
   - 功能点可转为-代码行

### 八、进度管理

- Gantt图和PERT图了解，15年后基本没考过
- 必考项目活动图

#### Ⅰ、Gantt图

1. Gantt图不能清楚描述各个任务之间的依赖关系

#### Ⅱ、PERT图

1. PERT图不能清晰地描述：各任务之间的并行情况

<img src="assets/2024-05-19 202832.png" style="zoom:75%;" />

- 最早开始时间：一个节点有多个入度，选择时间**最大**的作为最早开始时间
- 最迟开始时间：从结束节点计算，一个节点有多条出度，选择时间**小的**
- 松弛时间：
- 关键路径：时间最长的一个

#### Ⅲ、项目活动图

> 某软件活动图如下，顶点表示项目里程碑，边表示持续时间，完成该项目最少__天，活动BD最多可以晚开始\_\_天，不会影响整个项目进度

![](assets/2024-05-11 135949.png)

- 从开始到结束：选择数值大的

- 从结束到开始：选择数值小的

- 完成项目最少天数 / 求关键路径：

  - 求关键路径，关键路径是消耗时间最长的路径

  - 关键路径可能有多条

  - 关键路径：$A\to B\to D\to G\to I\to K\to L$ 

- 活动最多可以晚天数（推迟开始时间、松弛时间）：

  - **活动在关键路径上**：一天都不能晚（0）

  - 活动不在关键路径上：

    活动松弛天数 = 关键路径长度 - 当前路径的长度（例如：A$\to$B）

    当前路径的长度：包含A$\to$B的路径（花费大的）

- 活动最早开始天数：（例如：A$\to $B）

  - 注意：应加上最早开始时间

  - 活动在关键路径上：直接由最早开始时间相加获得

    > 活动AB最早从1天开始，活动BD最早开始时间：2 + 最早开始时间

  - 活动不在关键路径上：多条路径，选择时间大的路径

    > 活动AB最早从1天开始，活动FJ最早开始时间

    $A\to B\to F$ ：花费时间为 2 + 4 + 最早开始时间 = 6，最早开始时间为：6

### 四、风险管理

1. 风险管理一般包含2个特性：不确定性和损失

2. 风险是可能发生的事、对其进行干预，可能会减少损失

3. 风险管理不能只看风险造成的损失，来对风险排优先级

4. 风险不能完全去除，不能去除所有风险

5. 项目开发过程中，需要定期评估风险

6. 风险管理包括：项目风险、技术风险、商业风险

   项目风险：项目复杂度、规模、结构不确定


风险识别：

风险预测：风险预测从2个方面评估，风险发生可能性（概率）、风险产生的后果

风险评估：定义风险参照标准

风险控制

- 风险控制目的是辅助项目建立处理风险的策略
- 应对风险的最好办法就是主动避免风险，风险避免是最好的风险控制策略

### 十、软件质量

1. 一个软件的时间和资源质量特性属于效率质量特性
2. 恢复性能和受影响的数据，易恢复性（没有容错性）
3. 将用户数据与其他用户数据隔离开，安全性（功能性中的）
4. 功能性：适合性、准确性、互用性、依从性、安全性
5. 效率：时间特性、资源特性
6. 易使用性：易理解性、易学性、易操作性
7. 可维护性中有：易分析性、易改变性、稳定性、易测试性
8. 可移植性：适应性、易安装性、一致性、易替换性

## 面向对象

### 一、基础构成

1. **面向对象设计**与**面向对象分析**是面向对象软件工程中2个重要阶段
2. 面向对象设计应该依赖于面向对象分析的结果
3. 面向对象设计产生的结果在形式上可与面向对象分析产生的结果类似，都可以使用UML表示
4. 关联（Association)的特殊种类
   - 组合（Composition)：一种很强的“拥有”关系。组合成的新对象完全支配其组成部分，
   - 聚合（Aggregation)：但其程度不如组合强，

#### Ⅰ、类、对象、消息

1. 类是对象的抽象、—组对象的抽象定义

2. 对象是封装一组数据和行为的集合、是运行的实体，其组成部分不包括消息（消息是外部的）

3. 类的分类

   - 控制类：用于控制活动流、充当协调者
   - 实体类（数据类）：核心类，保存系统中，有大量的属性
   - 边界类（接口类）：系统内部与外部联系的媒介，有大量的方法

4. 类中一般与特殊关系

   一般是名称，如交通工具

   特殊是具体的，如汽车

5. 类可用创建很多对象，类是具有相同属性和服务的一组对象的集合

6. 对象由对象名、属性（状态）、操作（行为）三个部分组成

7. 类定义的对象，这些对象共享**属性、行为** 

8. 参数不相同的同名方法：重载

9. 发生在继承中，同参数的方法：重写（覆盖）

10. 面向对象设计，对象之间通过消息通信

#### Ⅱ、封装、继承、多态

1. 封装是一种信息隐藏技术，其目的是使对象的使用者和生产者分离

   封装：将逻辑上相关的数据以及行为绑定在一起，使信息对使用者隐蔽

2. 两个类及以上作为一个类的超类（父类）时，称为多重继承

3. 多重继承可能会造成二义性

4. 继承在已存在的类的基础上创建新的类（添加新方法）

5. 采用继承机制创建子类时，子类中可以有新的属性和行为

6. 继承定义了超类和子类的关系（继承才会出现子类、父类、超类）

7. 继承是父类和子类之间共享数据和方法的机制

8. 过载多态：指同一个名字在不同**上下文**代表不同含义

9. 包含多态：最常见的例子是**子类泛型化**

10. 参数多态：关键字最纯多态、应用广泛

11. 强制多态：编译程序通过语义操作，强制类型转换

12. 不同对象收到同一消息会产生不同结果这是多态，多态由继承机制支持

#### Ⅲ、动态绑定、静态绑定

1. 绑定在编译时是静态绑定（关键字编译）【重载】

   > () 是指过程调用和响应调用所需执行的代码在编译时结合

2. 绑定在运行时是动态绑定（关键字运行）【重写】【覆盖】

   > () 是指过程调用和响应调用所需执行的代码在运行时结合

3. **动态绑定**支持多态

#### Ⅳ、面向对象设计原则

1. 依赖倒置原则：细节依赖抽象，抽象不依赖细节（高层模块不依赖底层模块）、针对接口编程，不依赖于实现

2. 开闭原则：软件应该对扩展开放，修改关闭（不修改源代码，添加新功能）

3. 里氏代换原则（LSP）：父类（基类）可用出现的地方，子类一定可用出现，子类可以替换父类

   （一般使用父类保存子类对象）

4. 单一责任原则：一个类应该有一个引起它变化的原因、设计目的单一的类

5. 共同封闭原则：一个变化只对一个对象产生影响，其他对象不产生影响、

6. 接口分离：关键字接口，使用多个专用接口比单一的接口效果好

   不应该强迫客户依赖于它们不用的方法。

7. 组合重用：关键字**重用**，尽量使用组合实现代码重用，而不是继承

8. 共同重用：一个包里的所有类应该是**共同重用**的，若重用了包里的一个类，就应该重用包中的所有类

### 二、设计模式

1. 设计模式要素：模式名称、问题、解决方案、效果
1. 面向对象设计开发过程中，采用设计模式复用成功的设计

#### Ⅰ、分类

- 结构型模式：将抽象部分与其实现部分分离,使它们都可以独立地变化

| **范围/目的** | **创建型模式**                       | **结构型模式**                                               | **行为型模式**                                               |
| ------------- | ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **类模式**    | 工厂方法                             | （类）适配器                                                 | 模板方法<br/>解释器                                          |
| **对象模式**  | 单例<br>原型<br/>抽象工厂<br/>建造者 | 代理<br/>（对象）适配器<br/>桥接<br/>装饰<br/>外观<br/>享元<br/> 组合 | 策略<br/>命令<br/>职责链<br/>状态<br/>观察者<br/>中介者<br/>迭代器 <br/>访问者 <br/>备忘录 |



#### Ⅱ、总览

1. 简单工厂模式

   - 定义一个工厂类，可以根据不同参数返回不同的实例，被创建的类都有共同的父类
   - 结构图关键字：Factory

2. 工厂模式

   - 结构图关键字：Factory、interface(接口)
   - 当一个类希望由他的子类指定需要创建的对象

3. 抽象工厂(Abstract Factory)模式：

   - 结构图关键字：AbstractFactory
   - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
   - 一个系统要独立于他的产品创建、构成、表示
   - 可用于一个系统要由多个产品系列中的一个来配置时
   - 当强调一系列相关的产品对象的设计以便进行联合使用
   - 提供一个产品类库，只想显示他们接口而不是实现
   - 为图形用户组件定义不同的平台并进行类层次结构适合使用抽象工厂类

4. 生成器模式

   - 结构图关键字：Director（使用生成器的对象）、Builder（生成器）
   - 关键字：复杂对象
5. 原型模型

   - 结构图关键字：Prototype
   - 使用原型实例指定创建的对象的种类，并且通过复制这些原型创建新的对象
6. 单例模式

   - 结构图关键字：Singleton
   - 保证一个类仅有一个**实例**，并且提供一个可以访问的全局访问点

7. 适配器设计模式
   - 结构图关键字：Adapter
   - 适配器模式使得**原本不兼容的接口**可以在一起工作
   - 既是类结构型模式，又是对象结构型模式，与桥接类似
   
8. 桥接设计模式
   - 结构图关键字：Implementor（用于定义实现接口）
   - 每一个部分可以**独立**的工作、将对象的抽象和其实现分离，从而可以独立地改变它们。
   - 不希望在抽象和它的实现部分之间有一个固定判定关系
   - 例如：可以为每个Web应用创建不同的主题样式，如浅色或深色等
   
9. 组合设计模式
   - 结构图关键字：
   
     component：（提供的接口操作、存储子组件，实现子组件相关操作）
   
     client：（通过component提供的接口操作）
   
     Composite：定义有子部件的那些部件的行为
   
   - 组合模式将对象组合成树形结构以表示“**部分-整体**”的层次结构
   
   - 组合模式使得用户对单个对象和组合对象的使用具有一致性
   
10. 装饰器模式

       - 结构图关键字：Decorator

       - 动态地给一个对象添加一些额外的职责

       - 用于为一个对象添加更多功能而不使用子类的

11. 外观模式

       - 结构图关键字：Facade、有一个大方块包住了很多功能

       - 为子系统的一组接口提供一个统一的界面，Facade定义了一个高级接口，使得子系统更加容易使用

       - 为复杂的子系统提供一个简单接口

       - 例如：超市销售系统

12. 享元模式

       - 结构图关键字：Flyweight

       - 运用**共享**技术有效的支持大量细粒度的对象

       - 因使用大量的对象而造成很大的存储开销时

13. 代理模式

       - 结构图关键字：Proxy

       - 为其他对象提供一种代理**控制对这个对象的访问** 

14. 责任链设计模式

       - 结构图关键字：Handler
       - 关键字：链
       - 进多个对象的请求连成**一条链**，并沿着这条链传递请求
15. 命令模式：

       - 结构图关键字：Command、Operation（声明执行操作接口）
       - 通过将请求封装为一个对象，可将不同的请求对客户进行**参数化**
       - 对请求或排队支持可撤销
16. 解释器模式（了解）

       - 结构图关键字：AbstractExpression、Interpreter
       - 给定一中语言，定义他的语法，并定义一个解释器，解释文中句子
17. 迭代器模式

       - 结构图关键字：Iterator
       - 提供一种方法，**顺序访问**对象的各个元素
18. 中介者模式

       - 结构图关键字：Mediator
       - 中介者模式使用一个中介对象封装一些列对象交互，使对象之间不需要显示引用，使其耦合松散
       - 一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系**结构混乱**且难以理解。
       - 欲使一个后端数据模型能够被多个前端用户界面连接
       - **中介者与观察者是相互竞争模式**
19. 备忘录模式

       - 结构图关键字：Memento、
       - 在不破坏封装性的前提下捕获一个对象的内部状态
20. 观察者模式

       - 结构图关键字：Observer、subject
       - 定义对象间一对多的依赖关系，当一个对象改变时，所有依赖他的对象都会接收通知和更新，
       - 最主要的特征是使所要交互的对象尽量松耦合
       - 一个对象改变需要改变其他对象
       - 一个对象（subject）可以有多个观察者
       - Observer至少要维护一个对象
       - subject需要通知observer自身的变化
       - **发布-订阅模式**适合使用观察者模式
21. 状态模式

       - 结构图关键字：state
       - 允许一个对象在**内部状态**改变时改变他的行为
       - State定义了一个接口，其子类实现与特定状态相关行为
       - connect对象收到其他类请求时，根据自身状态做出不同响应
22. 策略模式

       - 结构图关键字：strategy
       - 定义一系列算法，把他们封装起来，并使他们可以互相替换，此模式使算法独立于客户
       - 需要使用一个算法的不同变体、题目中包含算数类的描写
       - 一个系统需要支持不同时期推出、打折、返利、满减不同的促销
23. 模板模式
    - 结构图关键字：class
    - 定义一个操作算法骨架，将一些步骤延迟到子类中
24. 访问者模式
    - 结构图关键字：visitor、accept方法
    - 表示一个作用于某对象结构中的各个元素的操作，它允许在不改变元素类型的前提下定义这些元素的新操作
    - 超市购物采用了访问者模式

### 三、UML

1. 设计视图的静态方面由（类图）和（对象图）表现，动态方面由交互图、状态图和活动图表现
2. UML中接口可用于：声明对象类所需要的服务

#### Ⅰ、事务

<img src="/assets/2024-05-21 195203.png" style="zoom:75%;" />

![](/assets/2024-05-21 195336.png)

1. uml有4种事务：结构事务、行为事务、分组事务、注释事务
   - 类、接口、构件属于结构事务
   - 一个依附于一组元素之上，对其进行约束或解释的简单符号，注释事务

#### Ⅱ、类图中关系

1. 有4种关系：依赖、关联（组合、依赖）、泛化、实现

   

关联关系：<img src="assets/2024-05-21 203947.png" style="zoom:75%;" />

- 关联描述了一组链，链是对象之间的连接，两个类之间可以有不同角色标识

- A $\underrightarrow{0..1 }$    $ \underrightarrow{0..*}$ B ：

   1个A对应0个或多个B

   1个B对应0个或1个A

聚合关系：<img src="assets/2024-05-21 204022.png" style="zoom:75%;" />

   - （A $-\square$ B）众多A组成B，每一部分可以独立存在
   - 关键字：部分、整体、生命周期不同
   - 例如：车辆中，轮胎、引擎等

组合关系：A $-\blacksquare$ B

   - A或B消失，则都消失

依赖关系：<img src="assets/2024-05-22 152031.png" style="zoom:75%;" />

   - A $\cdots >$​B （A依赖B）
   - 依赖是2个事务之间的语义关系，一个事务发生变化，会影响另外的事务发生变化
   - A调用/使用B类，A的其他部分代码都不涉及B
   - 类A需要使用标准

泛化关系：<img src="assets/2024-05-22 151849.png" style="zoom:75%;" /> （A $-\triangle$ B）

   - 子类A指向父类B

   - 例如：父类机器人类，子类无人机，子类扫地机，

     > 迷宫内有2种机器人，无人机和扫地机

实现关系：<img src="assets/2024-05-22 151937.png" style="zoom:75%;" />

   - 类A指向接口B
   - 类与接口之间最常见的关系
   - 箭头指向的是接口类

#### Ⅲ、用例图中的关系

#### 类图

- 展现了一组对象、接口、协作和它们之间的关系

<img src="assets/2024-05-22 151046.png" style="zoom:75%;" />

修饰符：

- +：public公有方法
- -：private私有方法
- #：Protected受保护方法
- ~：package包
- 没有修饰符：default默认的
- 注意<<interface>>定义的方法，子类必须实现
- A->B：A构造一个使用B接口的对象

#### 对象图

- 展现了某一时刻一组对象以及它们之间的关系
- 与类图相同，类名更加详细（特点带有“：”）

#### 用例图

- 展现了一组用例、参与者（Actor）以及它们之间的关系

<img src="assets/2024-05-22 153334.png" style="zoom:75%;" />

- 用例图关系包括：

  包含：虚线加箭头，主体的一部分（大功能指向小功能）

  扩展：虚线加箭头，分离在外的功能连接上主体（小功能指向大功能）

  泛化：实线加三角

- 特点是有参与者、参与者表示人、硬件、或其他系统可扮演角色

- 记住途中图例解释

- 包含扩展带有英文说明

#### 交互图

- 包含时序图、通信图

- **序列图（顺序图）**：强调消息时间顺序的交互图（关键字：时间）

  用于展示一个用例和多个对象的行为

  <img src="assets/2024-05-22 161053.png" style="zoom:75%;" />

  - 发送消息：—>（调用方法箭头指向类中的方法）
  - 返回消息：-->

- **通信图**：强调接收和发送消息的对象结构组织图

  <img src="assets/2024-05-22 161506.png" style="zoom:75%;" />

  - 特点：带有“：”
  - 通信图表示：对象之间消息流及其顺序
  - c：Client表示对象
  - ：Transaction匿名对象

#### 状态图

![](assets/屏幕截图 2024-11-02 161325.png)

- 展现了一个状态机、他由状态、转换、事件、活动组成
- 状态图用于描述一个对象在多个用例中的行为、通常对反应型对象进行建模
- 用于某些拥有多个状态的对象而不是系统中大多数或全部对象
- 可以用于用户界面或控制对象
- 活动可以在转换时执行也可以在状态内执行
- 监护条件只有在相应的事件发生时才进行检查
- 事件触发转换

#### 活动图

- 特殊的状态图

<img src="assets/2024-05-22 163236.png" style="zoom:75%;" />

- 适应于：复杂用例中业务处理流程进行进一步建模
- 并发分岔，应选“分叉”

#### 构件图（组件图）

- 构建之间的组件和依赖
- 组件之间的组织和依赖

<img src="assets/2024-05-22 163353.png" style="zoom:75%;" />

- order System调用InventorySystem的Product Accessor接口

#### 部署图

- 是用来对面向对象系统的物理方面建模的方法

<img src="assets/2024-05-22 163740.png" style="zoom:75%;" />

- 部署图通常在实施阶段使用
- 体现软件与硬件组件之间的物理关系





## 算法设计

1. 动态规划算法

    - 关键字：重叠子结构
    - 关键字：发现问题具有最优子结构、子结构都是最优子结构
    - 子问题被重复求解
2. 贪心算法

    - 默认时间复杂度：$O(n^2)$ 
    - 典型：迪杰斯特拉算法、邻分（分数）背包、Prim、Kruscal、哈夫曼编码
    - 哈夫曼编码节省21%-27%的存储空间
3. 回溯算法

    - 典型：N-皇后问题、深度优先的方式探索空间
4. 分治算法（特点将数据分成1部分或多部分）
    - 典型：归并算法、分治、折半查找
    - 递归相关算法
5. 分支算法
    - 了解问题的解空间，以广度优先的方式搜索解空间

> 背包问题：共有5个物品，背包容量为w=10，物品得重量w={2, 2, 6, 5 ,4}，价值v = {6，3，5，4，6} 求最包的最大价值，

- 0-1背包问题：包的最大价值

    从价值最大的开始算起，价值最大的是6，其对应的重量为：2，4；组合：{w2，v6 }、{w4，v6}；

    已选了重力2，4两个，总重量为10，所以最终只能放下{w2，v3}

    所以最终放下了3样：{w2，v6 }、{w4，v6}、{w2，v3}总价值为：6+6+3=15

- 部分背包问题：

    计算单个物品价值公式：$v / w$；

    物品的单位价值为：3、1.5、0.83、0.8、1.5

    根据单位价值选取**单位价值最大**的物品，且计算物品的重力为10

    根据重力w计算：$2+2+4+0.83\times2 = $​ 

算法复杂度计算

1. $O(n^2)$：$T_{n}=T_{n-1}+n$或$T_{n}=T_{n+1}+n$ 
2. $O(n^3)$：$T_{n}=K_1T(n/2)+n^2$   
3. $O(nlg^2n)$：$T_{n}=K_1T(n/2)+nlgn$    

优先队列是一种常用的数据结构，通常用堆实现，向优先队列中插入—个元素的时间复杂度为（ $O(lgn)$）

## 编译原理

1. 中间代码
    - 可以跨平台
    - 不同的高级语言可以产生同一种中间代码
    - 使用中间代码有利于进行与机器无关的优化处理
    - 使用中间代码有利于提高编译程序的可移植性
    - 常用的中间代码：后缀式、三地址码式、语法树
    
2. 编译程序
    - 编译程序分析源程序的阶段是词法分析、语法分析、语义分析

        语法分析：标点符号错误、表达式中缺少操作数、语言结构上的错误

        词法分析：非法字符、单词拼写错误等

        语义分析：类型检查
    
    - 对于可执行语句，翻译成中间代码或目标代码
    
3. 语法制导翻译是一种静态语义分析方法

4. 语法分析分为：自上而下、自下而上分析

    - 自上而下：递归下降分析法、预测分析法
    - 自低向上：移进-归约分析法
    
5. 编译器中，中间代码生成、代码优化并不是每一个编译器所必须的

## 数据库

1. 同时应看数据库关系系统.md第一章
2. 分布式数据库有分片透明、复制透明、位置透明、逻辑透明
    - 分片透明：不需要知道**逻辑上**访问的表具体是怎么分块存储的
    - 复制透明：复制技术的分布方法、用户不知道复制的哪些数据，如何复制
    - 位置透明：用户无需知道数据存放的物理位置
3. 分片透明：是指用户或应用程序不需要知道逻辑上访问的表具体是怎么**分块存储**的。
4. 复制透明：是指采用复制技术的分布方法，用户不需要知道数据是**复制**到哪些节点，如何复制的。
5. 位置透明：是指用户无须知道数据存放的**物理位置**。
6. 逻辑透明：即**局部数据模型透明**，是指用户或应用程序无须知道局部场地使用的是哪种数据模型。

> 例题01

<img src="assets/2024-05-11 170238.png" style="zoom:75%;" />

- 元件关系主键：根据函数依赖关系F可以确定

  由$\to$ 符号左边有：元件号、元件号供应商、供应商

  去重得元件号，供应商即为主键

## 操作系统

1. 系统级初始化的主要任务是：以软件初始化为主，主要进行操作系统的初始化

2. 操作系统层次结构

   ``` shell
   |-应用软件
   |    |--面向：用户
   |    |--各种常见的普通软件
   |
   |-系统软件
   |    |--面向：应用软件开发人员
   |    |--汇编软件、编译软件、解释器等
   |    |--数据库系统管理软件
   |
   |-操作系统
   |    |--面向：系统软件开发人员
   |
   |-计算机硬件
   	 |--面向：系统软件开发人员
   	 
   ```

### 一、进程管理

#### Ⅰ、前趋图

1. 程序顺序执行图
2. 前趋图是一个有向无环图：<img src="assets/2024-05-15 122750.png" style="zoom:65%;" />
3. PV 操作
   - P：申请资源，申请前驱节点的信号
   - V：释放资源，通知后续节点

> 例题 00

<img src="assets/2024-05-15 125032.png" style="zoom:75%;" />

- 由图确定信号S1、S2、S3、S4的位置

  一般都是由上到下、由左到右进行标注

- 25空：P1执行后应释放信号量$V(s_1)、V(s_2)$ 

- 26空：C应$P(s_2)、P(s_3)$、D应是$P(s_4)$ 

> $P_1\to s_1\to P_2\to s_2\to P_3$ 

- $P_1释放资源V(s_1)$
- $P_2申请资源P(s_1)，释放资源V(s_2)给P_3$​ 

#### Ⅱ、前驱图

1. 程序并发执行的图

   列：并行执行

   <img src="assets/2024-05-15 130036.png" style="zoom:75%;" />

2. 程序并发执行的特征

   - 失去了程序的封闭性
   - 程序和机器的执行的活动不在一一对应
   - 并发程序的相互制约性

#### Ⅲ、进程的状态

三态模型：

- 运行态：正在被CPU处理的情况
- 就绪态：等待CPU处理的情况（其他资源都拥有）
- 阻塞态：等待某一事件的发生（没有资源，也没有CPU）

<img src="assets/2024-05-15 145911.png" style="zoom:75%;" />

1. 运行态 → 阻塞态：等待使用资源；如等待外设传输；等待人工干预。
2. 运行态 → 就绪态：运行时间片到；出现有更高优先权进程。
3. 阻塞态 → 就绪态：资源得到满足；如外设传输结束；人工干预完成。
4. 就绪态 → 运行态：CPU 空闲时选择一个就绪进程。

五态模型：新建态、运行态、就绪态、等待态、终止态

1. 新建态：只能切换到就绪态、在这个阶段操作系统会为进程分配资源、初始化**PCB**。
2. 运行态可以到终止态

>  在单处理机系统中，采用先来先服务调度算法。系统中有4个进程P1、P2、P3、P4 （假设进程按此顺序到达），其中P1为运行状态，P2为就绪状态，P3等待打印机，P4等待扫描仪，若P1 __(23)\_\_，则P1、P2、P3、P4 的状态为：(24)

- 由题目得：

  1. 注意：P1转变成就绪态并不意味着释放了打印机扫描仪资源
  2. 注意：P1释放打印机扫描仪资源，并不意味着P1转换为就绪态
  3. P1正在运行、P3P4阻塞中、P2等待时间片调用

- 因为P1为运行态，有2种转换

  P1$\to$就绪态（时间片结束）

  P1$\to$阻塞态（等待事件发生）

- 若P1$\to$​就绪态：时间片结束，调用**就绪态P2**

- 若P1$\to$阻塞态：等待事件发生

- P3$\to$就绪态、P4$\to$​就绪态需要**运行态P1**释放对应的资源

#### Ⅳ、进程间通信

1. 同步是合作进程的直接制约问题
2. 互斥是申请临界资源间接制约问题
3. 利用PV操作，可以实现进程同步和互斥使用
4. 信号量S>0：表示系统中有资源可用
5. 信号量S<0：表示系统中等待资源的进程 
6. P操作 = S - 1（每申请1个资源，信号减1）

> 假设系统采用PV操作实现进程同步与互斥，若有n个进程共享1台打印机，那么当信号量为 -3 时，系统中有__个进程等待使用打印机

- 信号量S < 0时表示系统中有 | S |个进程等待使用
- S=-3，|S| = 3，所以系统中有3个进程等待使用

> 假设系统采用PV操作实现进程同步与互斥，若有n个进程共享2台打印机，那么信号量的取值范围

- 信号量取值范围：系统中可用资源 —  系统需求资源
- 系统可用资源（信号量）= 2（2台打印机）
- 系统需求资源：-(n-2)

#### Ⅵ、进程资源图

![](assets/20201031153118302-1715323201363-2.png)

- 答案：

  - （5）：B

  - （6）：C

- 解题思路，以（a）为例：

  先进行资源分配

  1. R1资源分配给P1-1，P2-1
  2. R2资源分配给P1-1，P2-2

  进程再申请资源（注意：申请的资源不包括上一步已经分配的资源）

  1. P1申请R2，不满足，R资源已经分配完毕
  2. P2申请R1，不满足，R资源已经分配完毕

- 能不能化简：能化简即非死锁进程，死锁就不能花间

### 二、死锁

1. 必要条件：
   - 互斥：只有对互斥的资源争抢才会造成死锁
   - 请求和保持条件：当已经锁定一个资源时，需要再请求其他资源，不释放已经占有的资源
   - 不可剥夺：进程资源不能强行被其他进程剥夺
   - 循环等待条件：存在一种进程资源的循环等待链
2. 处理死锁：预防死锁、避免（银行家算法）、检测解除（允许发生死锁）。
3. P代表进程，R代表资源

> 某系统有3个进程竞争资源R、每个进程需要5个资源，至少需要多少个R才能保证不发生死锁

- 会发生死锁的情况：每个进程需要5个资源

  每个进程分配4个资源（共12个资源）

- 不会发生死锁：发生死锁情况的资源数 + 1

> 09年上

<img src="assets/2024-05-15 165916.png" style="zoom:75%;" />

- 发生死锁的公式：$ m < n\times(k-1)+1 $

  m：系统资源总数

  n：进程数

  k：进程需要资源数

- 计算a情况是否会发生死锁

  m = 2

  $1\times(2-1)+1 = 2 = m$ 所以不会发生死锁

- 计算e情况释放会发生死锁

  m = 4

  $3\times(3-1)+1 = 7 > m$ 会发生死锁

### 三、死锁处理

1. 死锁处理方式：鸵鸟策略（不理睬）、预防策略、避免策略、检查死锁

> 银行家算法（避免策略）

<img src="assets/2024-05-16 105513.png" style="zoom:75%;" />

- 根据图示算出，进程仍需资源，系统剩余资源
- 例如P1，仍需资源为5、3、1，系统剩余资源：7、6、3

### 四、线程

1. 一个进程内的线程之间可以共享这个进程的全部资源（代码、全局变量、文件等）
2. 线程之间是不可见的，线程与线程之间的资源不能共享（线程栈指针不可共享）

### 五、程序局部性原理

1. 时间局限性：刚访问过，在不久的将来被访问的概率大
2. 空间局限性：刚访问过，在不久的将来被访问的概率大

<img src="assets/2024-05-16 115548.png" style="zoom:75%;" />

- 原则：
  - 页帧号为空，不在内存中（例如题中：页号1，不在内存中）
  - 状态位、访问位、修改位为0的优先调出内存
- 答案应为：D

### 六、分页存储管理

<img src="assets/2024-05-16 124112.png" style="zoom:75%;" />

1. 逻辑地址结构是：页号+页内地址

2. 页内地址：

   - 计算机系统页面大小为$4K\to 2^{12}\to$ 页面地址的位数为12位（bit）$\to$​对应十六进制3位（12/4=3）
   - 业内地址是十六进制得3位
   - 1C20H$\to$ C20是业内地址

3. 页号：逻辑地址去除业内地址既是$1C20H\to1$是页号

4. 物理地址：物理块号+页内地址

   逻辑地址页号1对应物理地址块号3：3C20H是物理地址

### 七、分段存储

<img src="assets/2024-05-16 174639.png" style="zoom:75%;" />

- 最多有__段：$31-24+1=8\to2^8=256$个段
- 每个段**最大**允许有__个页：$23-12+1=12\to2^{12}=4096$个页
- 页的大小：$11-0+1=12\to2^{12}=4096bit = 4K$​ 

### 八、磁盘调度算法

1. 先到先服务：不考虑磁头位置，根据顺序依次服务
2. 最短寻道时间：优先考虑距离磁头近的磁道
3. 扫描算法（电梯调度）：类似电梯，接到最外围一个顾客即返回
4. 单向扫描算法：类似打印机的转向
5. 注意柱面号，与磁头号，扇区号无关，计算磁盘调度算法顺序时
6. 先到先服务与最短寻道算法会随时改变磁头方向

### 九、多级索引

> 某文件采用链式存储，磁盘块大小为1024字节，文件M由5个逻辑记录构成，每个逻辑记录大小与磁盘大小相等，并依次存放在121、75、86、65、114号磁盘上，若要读取5120字节数据应访问__号磁盘

- 由题意链式存储：$121\to75\to86\to65\to114$
- 每块磁盘1024字节，所以字节应是$1-1024\to1025-2048\to2049-3512\to3513-4096\to4097-512$ 

### 十、位示图

> 某文件管理系统建立位视图，记录磁盘使用情况，若系统字长32位，磁盘上的物理块编号依次为0、1、2、3.。。。那么4096号磁盘块的使用情况在位示图第__个字中描述；若磁盘容量为200GB，物理块大小为1MB，那么位示图的大小为\_\_个字

- $4096 ÷ 32 = 128$；

  因为从0开始编号，所以128+1=129，4096号磁盘块在第129个字中描述

- 位视图求法：

  容量转换：$200GB=200GB \times1024 = 204800MB$ 

  计算物理块： $204800MB ÷ 1MB = 204800$个物理块

  求大小：因为系统是32位，$204800块÷  32位=6400$个字

### 十一、微内核操作系统

|        | 实质                                                         | 优点                                                         | 缺点                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单内核 | 将图形、设备驱动及文件系统等功能<br>全部在内核中实现<br>运行在内核状态和同一地址空间。 | 减少进程间通信和状态切换的系统开销<br>获得较高的运行效率。   | 内核庞大,占用资源较多且不易剪裁。                            |
| 微内核 | 只实现基本功能                                               | 内核精练<br>便于剪裁和移植系统服务程序运行在用户地址空间<br>系统的可靠性、稳定性和安全性较高。可用于分布式系统 | 用户状态和内核状态需要频繁切换,<br>从而导致系统效率 不如单体内核。 |



## 多媒体基础知识

1. 水平分辨率表示显示器在横向上具有的像素点数目
2. CIF的分辨率为：352*288
3. 人耳能听到的频率：20Hz~20KHz
4. RGB 8:8:8表示颜色$2^{24}$种
5. dpi是显示器每英寸像素点
6. 一些媒体
    - 感觉媒体：直接作用于人的感官
    - 传输媒体：传输媒体的物理介质，光缆，电磁波等
    - 表示媒体：图像编码、声音编码等
    - 表现媒体：鼠标、话筒、进行输入输出的设备
7. 文件格式
    - WAV：声音格式
    - BMP：图片
    - MOV：视频、
8. FM改变数字载波，可以改变音调
9. FM改变信号幅度，可以改变音高
10. 声音信号数字化过程，首先要进行A/D转换
11. 数字语音信号采样频率为8KHz，因为语音信号定义频率最高位4KHz
12. 计算机数字音乐合成技术主要有FM、Wave Table；WaveTable合成音乐更好
13. 彩色打印机中所采用的颜色空间是（ CMY色彩空间）、计算机（RGB）、电视机（YUV=8:4:4）

> 10000张分辨率为1024$\times$768的真彩图片（32位）刻录到DVD上，假设每个光盘可以存放4GB数据，需要_光盘

- 图像数据量 = 图像总像素 $\times$ 图像深度(b)

    $1024\times768\times32 = 25,165,824$

- 光盘数量 = 图像数据量$\div$ 每个光盘存放的数据量

    $(10000张 \times 25,165,824)\div 4GB = 7.3张$ ​

> RGB图，分辨率为256$\times$ 512，每一种颜色使用8b表示，则，这个图有多大

- $256\times512\times3(2^3=8)\times8$ 

## 网络与信息安全知识

1. 防范网络监听最有效的方法是：数据加密

2. 运行 Web 浏览器的计算机与网页所在的计算机要建立 （TCP） 连接，采用（www）协议传输网页文件。

3. 集线器的所有端口组成一个冲突域

4. 交换机是一种多端口网桥、交换机的各个端口形成一个广播域

5. 防火墙是指设置在不同网络或网络安全域之间的一系列部件组合

   是不同网络安全域之间信息的唯一出入口，

   能根据安全策略控制出入网络的信息流。

   一般由软件以及支持该廉运行的硬件系统构成

   能控制经过防火墙的双向信息，而不仅仅是某个方向的信息；

   防火墙可以过滤一些网络攻击，但一般无法定位攻击

   防火墙的主要支撑技术是包过滤技术。

6. CIF视频格式的图像分辨率为352×288

7. MPEG-I编码器输出视频的数据率大约为（1.5Mb/s）

8. 如果某主机开机后没有得到DHCP服务器的响应。则会发送无效的IP地址：169.254.X.X（windows） 和 0.0.0.0（linux）。

9. 路由器可以隔离ARP广播帧。

10. MPEG-I编码器输出视频的数据率大约为（1）。PAL制式下其图像亮度信号的分辨率为（352×288），帧速为（3）。

    MPEG视频中的时间冗余信息可以采用（帧间预测和运动补偿 ）的方法来进行压缩编码。

11. TLS安全协议位于传输层

## 加密技术和认证技术

1. 公钥体系中，私钥用于解密和签名，公钥用于加密和认证

   - 甲使甲的私钥进行签名$\to$乙使用甲的公钥进行解密
   - 网站申请CA证书，用户通过CA的公钥验证CA的签名
   - 网站从CA获取数字证书，证书使用CA的私钥进行数字签名

2. 数字签名：确保消息不可否认，是对真实性的保护

3. 数字证书：网络用户进行身份认证

4. 加密：用于确保数据的保证性

5. 认证：用于保证报文发送者和接收者的真实性

6. 对称密钥（私有密钥）：适合**大量明文进行加密并传输**。

   DES、3DES、**RC5**、IDEA、AES、RC4（注意RC、带有DE的字母、AES特别）

7. 非对称加密（公开密钥）：适合数字签名，进行身份验证

   RSA、ECC、DSA

8. MD5是**报文摘要算法**、对任意长度的文本计算结果都为128位，目的防止报文被篡改

9. SHA-1是一种安全散列算法，来确保**明文在传输过程中不会被篡改**；


## 知识产权基础知识

1. 根据专利法实施细则，职务发明创造是指：

     ①在本职工作中做出的发明创造；

     ②履行本单位交付的本职工作之外的任务所做出的发明创造：

     ③退职、退休或者调动工作后**1年内**做出的，与其在原单位承担的本职工作或者原单位分配的任务有关的发明创造。

     计算机程序代码、游戏的规则和方法、计算机算法都不能取得专利权

2. 不正当竞争法保护：描述商业秘密相关内容

3. 商标权：注册商标

     商标权的保护期是可以延长的

4. 著作权：是自作品完成之时就开始保护。

   向客户提供工具软件的复制品，这里侵犯了工具软件的软件著作权。

   接受他人委托开发的软件，其著作权的归属由委托人与受托人签订书面合同约定；无书面合同或者合同未作明确约定的，其著作权由受托人享有。

5. 合理使用指可以不经著作权人许可，不需支付报酬，使用其作品

6. 发表权的保护期受时间限制

7. 利用（商业秘密权）可以对软件的技术信息、经营信息提供保护。

8. 按照我国著作权法的权利保护期，以下权利中，（修改权 ）受到永久保护。

9. 有可能无限期拥有的知识产权是（商标权）

10. 商业秘密的构成条件是：商业秘密必须具有未公开性，即不为公众所知悉； 商业秘密必须具有实用性，即能为权利人带来经济效益；商业秘密必须具有保密性，即采取了保密措施。

11. 目前根据我国法律法规的规定必须使用注册商标的是烟草类商品。

12. 软件商标权的权利人是指软件注册商标所有人

13. 软件著作权的客体包括：源程序、目标程序、软件文档

14. 《中华人民共和国著作权法》和《计算机软件保护条例》是构成我国保护计算机软件著作权的两个基本法律文件。

## 下午题总结

1. 基本就是看图填空、注意纯虚函数的编写

### 一、数据流图

#### Ⅰ、基本符号

<img src="assets/eba1b595309143648518d358c55f62b4.png" style="zoom:100%;" />

#### Ⅱ、原则

1. 补充实体名称：根据说明和图文来确定，，

   > 注意：XXXX，SSSS这种结构
   >
   > 例如：信息维护，农业专家对农作物、环境监测数据的监控处理规则进行维护

   - 优先看信息比较多的图

   - 实体一般是句子的主语

   - XXXX并不意味着实体名称，可能意味着加工处理流程对应符号圆角方块

   - 注意数据流的箭头，应与原文指向的一致

     > 可视化，实时向农业人员展示检测信息（P5$\to$E3）

     <img src="assets/屏幕截图 2024-11-01 120415.png" style="zoom:75%;" />

2. 补充数据存储：根据说明和图文确定，没给出的要自己拟名（用户表等）

   > 表名要简短有效，有唯一指向说明的就直接添加“表”即可

   <img src="assets/屏幕截图 2024-11-01 122734.png" style="zoom:60%;" />

   - 有明确指向的，分析结果，预测信息，且图中唯一，直接在其后加表字，成为分析结果表，预测信息表

   > 在图中指向不明确，图中有多个关键字，需要根据说明确定

   ![](assets/屏幕截图 2024-11-01 123011.png)

   - 关键字“规则”不唯一，D1不能命名为规则表，需要根据说明确定
   - 在说明中的“信息维护”中查找“规则”

3. 补充缺失的数据流起点和终点
   1. 注意圆角方块（加工/处理）：输入输出都有
   2. 根据描述说明确定缺失，一句话一个流程，
   3. 根据父图和子图的平衡确定缺失

4. 问答题

   如何保持数据流平衡：

   1. 父图加工输入输出数据流要和子图加工输入输出数据流名字和数量一致
   2. 如果父图一个输入输出流对应子图几个输入输出流，而子图中组成这些数据流的全体正好是父图中数据流，那么他们仍然是平衡的

   “某某处理”可以分为那些子加工，进一步分解需要注意那些常见错误

   - 分解处理，找动词

     > 信息处理，对实时监测信息根据处理规则进行检测分析，将分析结果进行可视化并进行存储、远程控制、对历史监测信息进行综合统计和预测，将预测信息进行可视化存储

     - 对原文进行划分，去掉已有的功能

   - 常见错误：有输入没有输出，有输出没有输入，命名错误

### 二、数据库系统

#### Ⅰ、图形含义

<img src="assets/无标题.png" style="zoom:75%;" />

#### Ⅱ、原则

1. 辊距问题描述补充实体图

   - 补充联系：

     根据文中描述，添加没有表现出来的关系，需要一句话一句话对应

   - 补充关系（1:1、1:n、n:m）

2. 根据描述补充关系模式的属性：直接根据说明填空

   若文中描述是全的，应补充响应的外键

   外键填写位置：

   | 关系         | 说明                                                         |
   | ------------ | ------------------------------------------------------------ |
   | 1：1（AB表） | 把关系上的属性放到任意一个表中（设A），并把 B表的主键放到一个 A表 中 |
   | 1：n         | **关系**上的属性放到 n表 中，把**1的主键**也放到n表中        |
   | n：m         | 将**关系属性**生成一个新表，并保存**nm表的主键**             |

3. 根据关系图选出主键与外键

   主键：自己的key；外键：其他表的key，外键可能有多个

   > 客户号唯一标识客户关系中的每一个元组

   - 客户号是主键

   > 部门号唯一确定部门关系的每一个元组，每个部门只有一个主管，

   - 部门号是主键
   - 部门与主管是1:1关系

   > 每个部门有多名员工，每个员工只属于一个部门

   - 部门与员工是1:n关系

### 三、UML图

参考上午题

### 四、算法题

1. 背诵数据结构-算法部分
2. 背诵本文-算法设计部分

### 五、面向对象

参考上午题，根据图填写代码
