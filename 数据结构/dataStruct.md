# 数据结构

## 概论

### 一、名词解释：

1. 数据：信息的载体
2. 数据项：数据的最小单位
3. 数据元素：数据的基本单位
4. 数据对象：数据元素的集合
5. 数据类型：原子、结构、抽象数据类型（可定义完整数据结构）
6. 逻辑结构：队列、栈、串、数组、树、图、有序表。
7. 存储结构：顺序结构（顺序存储、循环队列）、链式（所有的链表）、索引、散列（哈希表）
8. 数据物理结构：数据元素表示和关系表示

### 二、时间复杂度计算

$O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2)  < O(2n) < O(n!) < O(n^n)$ 

1、利用对数计算的时间复杂度（所有可以改写成while循环）

```c
// 例题：
void func(int n)
{
    int i;
    while(i<n)
    {
        i=i*2;
    }
}
```

- 根据while循环写出公式，注意i的初始值

| 次数k           | 1    | 2    | 3    | 4    | 5    |
| :-------------- | ---- | ---- | ---- | ---- | ---- |
| i的值           | 1    | 2    | 4    | 8    | 16   |
| 循环主体的值i*2 | 2    | 4    | 8    | 16   | 32   |

- 根据循环主体得到i与n的关系式：$2^k=n$
- 求得次数K关系式：$K=\log_2n$

2、for嵌套循环的时间复杂度

``` c
for(i=1;i<=n;i++)
{
    for(j=1;j<=2*i;j++)
    {
        m++;
    }
}
```

- 原则：有几个for就有几个累加，又因为m++就执行1次，所有m++为1
- 得公式：$\sum_{i=1}^n\sum_{i=1}^{2i}1$ 
- 计算方法，由右向左计算
  1. $\sum_{i=1}^{2i}1=1+1+1+...+1=2i$ （共累加2i次，每次都加1）
  2. $\sum_{i=1}^n2i=2\sum_{i=1}^ni=1+2+3+4+...+n=2\frac{n(n+1)}{2}=n^2+2$
- 因为时间复杂度只求近似值，所以时间复杂度为$O({n^2})$

3、递归时间算法



4、常见的累加计算方法：

- $\sum_{n=1}^{n}1=1+1+1+...+1=n$ （n个1相加等于n ）
- $\sum_{j=i}^{n}1=(n-1)+(n-2)+(n-3)...+1=\frac{n[(n-1)+1]}{2}$ 
- $1^2+2^2+3^2+...+n^2=\frac{n(n+1)(2n+1)}{6}$
- $\sum_{i=1}^n(i^2+i)=\sum_{i=1}^ni^2+\sum_{i=1}^ni$ （时间复杂度只是粗略计算，因此只关心**高阶**，所以$\sum_{i=1}^ni$可以舍去）

## 线性表

### 一、顺序存储

1、顺序表：线性表采用顺序存储

- 方便快速读取，可以插入读取指定序号的元素。
- 插入删除较慢（因为要移动大量数据），但在最后插入删除很快。

2、线性表中的头尾没有直接前驱或直接后继

3、顺序表中，在任意位置插入元素，元素平均移动次数是：$\frac{n+1}{2}$

4、顺序表中，在任意位置删除元素，元素平均移动次数是：$\frac{n-1}{2}$ 

### 二、链式存储

1、单链表必须在当前指针之后插入、双链表可以在元素前后插入

2、单链表为空条件

- 有头节点：head->next == NULL
- 不带头节点：head == NULL

3、单向循环链表，头插/尾插的时候，知道尾指针更快

4、双向循环链表，头插，知道尾指针效率高

6、长度为M和N得升序链表，

- 若将2个链表合并为**降序**（与原来的次序相反），则最坏的时间复杂度max(M,N)

- 若将2个链表合并为升序（与原来的次序相同），则最坏的时间复杂度M$\times$N

  <img src="dataStruct\合并链表.png" style="zoom:67%;" />

## 队列/栈

### 一、队列

1、队列：**头出队，尾入队**（记忆：与日常排队相同，面向的方向是队头，先进先出）

2、队列和栈都是限制存储点的线性结构

3、链表方式存储队列时，在进行插入运算时，只修改尾指针即可

4、最不适合队列的链表：非循环结构（包括非循环单链表、非循环双链表），因为普通链表无法快速找到头尾

### 二、循环队列

1、循环队列（默认队列情况）

- 什么时候用默认队列：
  1. 题目没有说明的情况
  2. front与rear初始化时指向同一个区域
  3. 指针A指向队头元素，指针B指向队尾元素的后一个位置
  
- 默认队列公式：
  1. 初始化：Q.rear = Q.front = 0
  
  2. 入队：Q.rear = (Q.rear+1) % MaxSize
  
  3. 出队：Q.front= (Q.front+1) % MaxSize
  
  4. 队满：Q.front==(Q.rear+1) % MaxSize
  
  5. 队空：Q.rear == Q.front
  
  6. 队中元素个数：(Q.rear+MaxSize-Q.front) % MaxSize 
  
     注意一定是rear-front
  
- 缺点：这种队满浪费了一个数据元素

2、队列技术

- 缓冲区利用了队列技术

### 三、前/中/后缀表达式

1、笔算方式：**中缀**表达式转**前/后缀**，只需要加括号（依据正常计算的流程），再把符号前移/后移即可

2、中缀转后缀（利用栈）：

1. 运算符入栈，数字不入栈
2. 当前运算符优先级>栈顶元素优先级，入栈
4. 当前运算符优先级<=栈顶元素优先级，**先弹出栈中的元素**，当前元素才可入栈
5. “（”直接入栈，遇见“）”出栈，而且是一直出到与之匹配的“（”

3、**前缀/后缀**表达式转**中缀**（利用栈）

1. 入栈方向是从数字端开始

2. 数字入栈，操作符不入栈

3. 遇见操作符则出栈，出栈的**数字顺序与前/后缀中的顺序**相同（）

   1. 前缀可以理解为：A-B中的A是**先出栈的**
     2. 后缀可以理解为：A-B中的A是**后出栈的**

4. 出栈元素＋操作符组成一个整体，再次入栈

   **出栈方向也符合（<--是方向）：后<--栈-->前**

### 四、栈

1、特点

- st栈空条件：st->top = -1
- 不论是顺序栈还是链栈，其入栈出栈的操作时间复杂度都为$O_{(1)}$ （因为只在栈顶操作）

2、若输入序列是1，2，3，……，n

- 输出序列第一个是n，则第i个元素是n-i+1

- 输出序列第一个是i（第一个元素不是n），则第j个元素是**不确定**

- 其出栈顺序是$P_1,P_2,P_3...$，若$P_2$=3（任意数），则$P_3$**可能取到的值**得个数是n-1（只有$P_2$是确定的，其他数都可取到）

- 特别注意入栈顺序（以上序列在栈中的顺序）：
  $$
  n\to 栈顶\\
  ……\\
  3\\
  2\\
  1\to 栈底\\
  $$
  

2、先序序列为abcd的不同二叉树的个数

- 这相当于问以abcd的顺序入栈，出栈的顺序有多少种
- 公式：$C_{2n}^{n}\frac{1}{n+1}$ （n是元素的个数）
- $C_m^n=\frac{m!}{n!(m-n)!}$
- $C_n^0=C_n^n=1$ 

3、共享栈

- 结构：共享栈2端是栈低，中间是栈顶
- 优点：节省空间，降低上溢发生率
- st栈满：top[1] + 1 = top[2]

4、链栈

- 最不适合做链栈的是：只有头指针，没有尾指针的循环单链表

5、向一个栈顶为top的链栈中插入一个节点（不带头节点）

- x->next=top; top=x

  <img src="dataStruct/d0c8a786c9177f3e578c49bb7ccf3bc79e3d56cf.png" style="zoom:50%;" />

## 串、矩阵

### 总结

1、子串的定位运算称为串的模式匹配，被匹配的主串称目标串。

2、求子串首次出现的位置算法叫匹配，子串称为模式。

3、设S为一个长度为n的字符串，其中的字符各不相同，则S中的互异的非平凡子串（非空且不同于S本身）的个数为：$\frac{n(n+1)}{2}-1$ 

4、若n为主串长，m为子串长，则串的朴素匹配算法在最坏的情况下比较字符总次数为：$(n-m+1)\times m$ 

### 一、KMP算法

- next数组：https://www.bilibili.com/video/BV1g341147vQ
- nextval数组：https://www.bilibili.com/video/BV1uJ411s7br
- 已知字符串ABAABBAA……，模式串ABAAA，则next与nextval是根据**模式串**生成的
- 注意模式串下标，一般是从1开始，若是从0开始，next要全体-1

| j（默认为1） | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串P      | a    | b    | a    | a    | b    | a    | a    | b    |
| next         | 0    | 1    | 1    | 2    | 2    | 3    | 4    | 5    |
| nextval      | 0    | 1    | 0    |      |      |      |      |      |

1、next求法

- 固定值：next[1]=0，next[2]=1 
- 当j=3时，j前面的字母是ab
  1. a,b没有相同的，则0+1=1
- 当j=4时，当前j前面字母时aba，（都是从左向右写）
  1. a（$j_1$）        | a  （$j_3$）    
  2. ab（$j_1,j_2$）| ba（$j_2,j_3$）
  3. 相同字符串最长的个数为1，则1+1 =2
- 当j=5时，当前j前的字母顺序为abaa
  1. a     | a
  2. ab   | aa
  3. aba | baa
  4. 相同字符串最长的个数为1，则1+1=2
- 当j=6时，当前j前面的字母为abaab
  1. a       | b 
  2. ab     | ab
  3. aba   | aab
  4. abaa | baab
  5. 相同字符串最长的个数为2，则2+1=3

2、nextval求法

- 固定值：nextval[1] = 0，nextval[2] = 1

- 若j>2（$P_j$为当前指向的字符串，j为当前指向得key值）
  1. $P_j\neq P_{next[j]}: nextval[j] = next[j]$   (next的值直接下移，成为nextval的值)
  
  2. $P_j=P_{next[j]}: $ 
  
     第一步：找到当前指点得$next值，这个值为a，再找到next[a],这个为b$ 
  
     第二步：找到$nextval[b]$ ，就是当前的nextval值

### 二、矩阵压缩做题技巧

1、选择题

- 优先区分矩阵下标与数组下标，矩阵下标从1开始，数组下标从0开始
- 优先画出矩阵样子，选定特定的值带入选项公式计算
- 上三角/下三角与元素下标、列存储和行存储（一般默认都是行存储）的关系

2、使用压缩存储**稀疏矩阵**的存储结构：三元组和十字链表

### 三、对称矩阵压缩

1、矩阵特点

- 对称的位置数值相同，例：$a_{21}=a_{12}$ 

  求解的元素并不在指定区域中，可以利用对称矩阵特性（$a_{ij}=a_{ji}$ ）转换

  例：10阶对称矩阵A，采用压缩存储方式，以行为主存储在下三角，$a_{11}$ 为第一个元素，则$a_{36}$的地址为

  【分析1】$a_{36}$ 是上三角元素（$a_{33}$ 是对角线元素），而数据存储在下三角，所有利用对称矩阵特性（$a_{ij}=a_{ji}$ ）求$a_{36}等价于求a_{63}$ 

  【分析2】$a_{11}$ 是第一个元素，不是从0开始存储，最终结果不用-1

- 只要是下标行列相同的元素

  1. 其位置肯定在对角线上，例如：$A_{11}、A_{22}$
  2. 一定是上三角的第一个
  3. 一定是下三角的最后一个

- 矩阵压缩，只需要存储一般的数据即可

$$
对称矩阵图例：
\begin{pmatrix} 
	a_{11} & a_{12} & a_{13} & \cdots & a_{1n} \\ 
    a_{21} & a_{22} & a_{23} & \cdots & a_{2n} \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\    
    a_{n1} & a_{n2} & a_{n3} & \cdots & a_{nM} \\ 
\end{pmatrix}
$$

3、计算方法**矩阵** $A_{ij}$ 在数组的下标位置，数组下标从0开始

- 计算前i-1行有多少元素**【特别注意：一定是到i-1行】**

  1. **下三角 $i\geq j$** 

     $C = 1+2+3+...+(i-1)=\frac{(1+i-1)(i-1)}{2}=\frac{i(i-1)}{2}$ 

  2. **上三角$i\le j$** 

     说明：矩阵 $A_{ij}$ ，第1行是n-1+1，第2行是n-2+1，第3行是n-3+1；所以第i行应该是n-i+1

     $C=n+(n-1)+(n-2)+...+(n-i+1)=\frac{(n-i)(n+n-i+1)}{2}$ 

  常用计算元素个数的方法，比使用公式快

  上三角例子：10*10矩阵，前5行=10+9+8+7+6

  下三角例子：10*10矩阵，前5行=1+2+3+4+5

- 计算第i行的元素【**-1是因为数组从0开始存放，若数组从1开始存放不用-1**】

  1. 下三角矩阵 

     数组下标K = C + j-1

  2. 上三角（$i \le j$）【**i=j是对角线的元素，j-i是相对于对角线移动了几个元素 **】

     数组下标K = C + j-i-1

### 四、三对阵矩阵压缩

1、矩阵特点

- 第一行，最后一行都是2个元素

- 中间元素下标i行j列，i=j

  前一个元素下标i行j列，i>j

  后一个元素下标i行j列，i<j

  例：$A_{43}A_{44}A_{45}$ 

$$
三对称矩阵图例：
\begin{pmatrix} 
	a_{11} & a_{12} & 0 & \cdots & & & 0 \\ 
    a_{21} & a_{22} & a_{23} & 0 &\cdots && 0 \\
    0 & a_{32} & a_{33} & a_{34} & 0 &\cdots & 0 \\
    \vdots & \vdots & \vdots &  & \vdots & \ddots &\\    
    0 & 0 & 0 & \cdots & a_{n,n-1} & & a_{nn} &\\ 
\end{pmatrix}
$$



2、计算方法：矩阵$A_{ij}$在一维数组中的位置

1. 计算去掉 **第i行** 和 **第一行** 一共有多少元素（注意每行3个元素）

   $C_z=3 \times (i-2)$

2. 矩阵A第i行j列一共有多少元素$A_{ij}$

   【第一行2个元素；第i行（除第一行）之前一共有多少元素】

   $总数C_{z1}=C_z+2$

3. 当前行元素

   i>j：+1

   i=j：+2

   i<j：+3

4. 因为数组中元素是从0开始，所以下标为总数-1

   $总数:C_{z1}-1$

### 五、上下三角矩阵

1、上三角矩阵
$$
上三角矩阵图例：
\begin{pmatrix} 
	a_{11} & a_{12} & a_{13} & \cdots & a_{1n} \\ 
    0 & a_{22} & a_{23} & \cdots & a_{2n} \\
    0 & 0 & a_{33} & \cdots & a_{2n} \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\    
    0 & 0 & 0 & \cdots & a_{nM} \\ 
\end{pmatrix}
$$


2、下三角矩阵
$$
下三角矩阵图例：
\begin{pmatrix} 
	a_{11} & 0 & 0 & \cdots & a_{1n} \\ 
    a_{21} & a_{22} & 0 & \cdots & a_{2n} \\
    a_{31} & a_{32} & a_{33} & \cdots & a_{2n} \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\    
    a_{n1} & a_{n2} & a_{n3} & \cdots & a_{nM} \\ 
\end{pmatrix}
$$


3、算法与对称矩阵相同，特殊的地方在于要有一个地方存放除上三角（下三角）之外的元素，所以是对称矩阵+1

### 六、其他数组存储元素

例：设二维数组A[1……m，1……n]按行存储在一维数组B中，则二维数组元素A[i,j]在B中的下标为

- 注意二维数组A，其元素下标为1……m，1……n；相当于对称矩阵
  $$
  对称矩阵图例：
  \begin{pmatrix} 
  	a_{11} & a_{12} & a_{13} & \cdots & a_{1n} \\ 
      a_{21} & a_{22} & a_{23} & \cdots & a_{2n} \\
      \vdots & \vdots & \vdots & \ddots & \vdots \\    
      a_{n1} & a_{n2} & a_{n3} & \cdots & a_{nM} \\ 
  \end{pmatrix}
  $$

- A[i,j]也是**矩阵下标**，下标从1开始，所以行可-1，列就不用-1；

  $A[i,j]在B位置的公式：(i-1)\times n+j$  

## 树与二叉树

### 一、常用基础

1、当公式没记清除时，可以用最少的3个节点的二叉树进行验证公式

- 二叉树不是树的特殊形式

2、总结节点数 = 分支数 + 1（与$n_0、n_2的公式不同$）

3、度为0（叶子节点）的个数 = 度为2的节点个数 + 1
$$
叶子节点=度为2的节点+1
\\
n_0 = n_2 + 1
\\
n_2 = n_0 - 1
$$
4、公式

- 高度为K的二叉树，整个二叉树最多有M个节点数（满二叉树或者完全二叉树最多节点数）：$M=2^k-1$  

- 高度为K的二叉树，整个二叉树最少有N个节点数（一条线的情况）：$N=2^{k-1}$ 

- 第i层最多有Z个节点：$Z=2^{k-1}$ 

- k层（高度为K）的完全二叉数树至少有S个节点：S=$2^{k-1}$ 

  说明：$2^{k-1}-1是前k-1行共多少节点，+1是第k行至少1个元素$ 

- 高度为k，度为M的树最多有x个节点：x=$\frac{(m^k - 1)}{(m - 1)}$ 

5、完全二叉树与满二叉树节点关系

- 二叉树的顺序存储，其节点的下标要满足父节点i，其子节点2i，2i+1的关系
- 二叉树左右子树有先后顺序，不能随意以更换；树的左右子树可以随意更换

<img src="dataStruct\二叉树关系.png" style="zoom:73%;" />



6、n个节点的完全二叉树树高（或者**二叉树最小高度**或者**二分查找**最大比较次数）
$$
当n能被log整解:\lfloor \log_2n \rfloor + 1
\\
当n不能被log整解:\lceil \log_2(n+1) \rceil
$$

### 二、树的遍历

1、树转换二叉树的本质：左孩子，右兄弟

2、将树转换为二叉树，再进行遍历

- 树的先序遍历（深度优先遍历） == 二叉树的先序遍历
- 树的后序遍历 == 二叉树的中序遍历
- 树的广度优先遍历 == 二叉树的层次遍历
- 树的深度优先遍历输出的是逆拓扑排序（不存在回路）

### 三、前中后遍历与节点关系

1、概述

- 空树、只有根节点 :left_right_arrow: 前后、前中、中后相同
- 只有一半孩子节点（相同情况）
  1. 左孩子为空（只有右孩子）:left_right_arrow: 前中相同（记忆：头中相同，画图）
  2. 右孩子为空（只有左孩子）:left_right_arrow: 后中相同（记忆：尾中相同，画图）
- **高度与节点数相同** :left_right_arrow: 前后相反
- 任意节点不能同时拥有左右孩子:left_right_arrow: 前中相反（待议）
- 任意节点没有左孩子:left_right_arrow: 中后相反（待议）

2、先序与中序、后序与中序可以确定唯一的二叉树

- 原则1：先序确定根节点（最左边的是根节点）
- 原则2：后序确定根节点（最右边的是根节点）
- 原则3：中序根据先序/后序确定的根节点划分左右子树（位置，在根节点的左边还是右边）

3、前序，后序可以确定祖先关系

- 原理1：当前序为XY，后序为YX则，X是Y的祖先
- 原理2：当前序为ABC，后序为EBA，则A是B的祖先，EC是B的孩子

### 四、二叉排序树

1、二叉排序是具有下列性质的二叉树：（左小右大）

- 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
- 左、右子树也分别为二叉排序树；

2、二叉排序树查找性能与输入数据有关（平衡二叉树是最优解）

3、生成二叉排序树，最坏情况是单支树；高度（深度）= 树的元素个数；n个元素，树高n

4、二叉排序查找路径（同折半查找关键字比较）

- 例：{95，22，91，24，94，71}能否构成二叉排序树路径
  1. 确定查找方向：2个元素（例：AB），查找有2种情况，大数（B>A）或者 小数（A>B）
  2. 验证是否符合情况：
     1. A>B;确定方向为小，除**确定查找方向**（AB）素外，剩下的元素都应小于A
     2. A<B确定方向为大，除**确定查找方向元（AB）**素外，剩下的元素都应大于A
- 查找元素（95，22），95>22，则剩余元素都应小于95；查找元素（22，91），22<91，则剩余元素都应大于22；（91，24），91>24，则以后的元素都应小于91，而94显然大于91所以不能构成二叉排序树路径。

### 五、平衡二叉树

1、平衡二叉树 $\iff$ 所有非叶子节点的平衡因子均为1

- 检查是否为平衡二叉树，可以查看中序遍历，中序遍历为增序序列是平衡二叉树

2、平衡二叉树N层的总节点数C的公式：$C_n=C_{n-1}+C_{n-2}+1$ 

- $共1层总节点数:C_1=1;$ 

- $共2层总节点数:C_2=2$ 

  例：6层，所有非叶子节点的平衡因子均为1，总节点数:

<img src="dataStruct\总节点数.png" style="zoom:50%;" />
$$
C_1=1\\
C_2=2\\
C_{3}=C_2+C_1+1 = 1+2+1 = 4\\
C_{4}=C_3+C_2+1 = 4+2+1 = 7 \\
C_{5}=C_4+C_3+1 = 7+4+1 = 12 \\
C_{6}=C_5+C_4+1 = 12+7+1 = 20
$$

3、平衡二叉树的调整

- 调整一步即可平衡

  1. 异侧（**需要交换位置**）

     <img src="dataStruct\平衡二叉树异向.jpg" style="zoom:67%;" />

  2. 单侧

  <img src="dataStruct\平衡二叉树同向.jpg" style="zoom:67%;" />

  

- 调整多步
  1. 计算个节点的平衡因子
  2. 找出不平衡的节点，从不平衡的节点开始，到最长的一条边得3个元素
  3. 将这3个点写成三角形平衡的二叉树，再将其他点重新插入到树中

### 六、哈夫曼树

1、特点：

- n叉树**带权**且**路径最小**
- 只有$n_0、n_2;n_0=n_2+1$元素（可用计算题第一题的公式计算）

2、节点哈夫曼树的创建与WPL

- 规则1：左小，右大

- 规则2：每次都要选择最小的节点数

  选择的2个最小节点之和，要重新添加进待排序数列，参与最小节点的选择

  <img src="dataStruct\哈夫曼树创建.png" style="zoom:50%;" />

- WPL计算方法（边数）

  只计算叶子节点

  公式：叶子节点的权值 $\times$ 到这个叶子节点的**边**的个数

  例：$WPL_{13}=13*3$ 

  例：$WPL_{15}=15*3$ 

  例：$WPL_{4}=4*5$ 

3、权集哈夫曼树创建

例：给定权集w={5，7，2，3，6，8，9}构造哈夫曼树

解：将权集的值当成节点，与节点哈夫曼树生成方式一样

4、哈夫曼树编码

- 生成哈夫曼树

- 只有叶子节点才可以求编码

- 左为0，右为1

  <img src="dataStruct\哈夫曼树编码.png" style="zoom:50%;" />

### 七、哈夫曼树计算

1、判断是否为前缀编码方案

- 按顺序写哈夫曼树，左0右1，若每一编码都是**叶子节点**，则是前缀编码

2、判断是否属于哈夫曼树

- 24、10、5和24、10、7有可能生成2个情况的树，如情况1，情况2

  <img src="dataStruct\哈夫曼树条件.png" style="zoom:50%;" />

7、已知字符集abcdef，若各字符出现的次数分别为6，3，8，2，10，4，则对应的字符集的哈夫曼编码是

- 直接用6,3,8,2,10,4**生成**哈夫曼树
- 然后根据字符集与字符出现的次数的对应关系，确定abcdef的位置
- 左0右1，进行哈夫曼编码

8、对于n个互不相同的符号进行哈夫曼编码，生成的哈夫曼树一共有M个节点，则n是多少

- 等价于知道叶子节点n，求所以节点M（计算题 1）
- 等价于n个叶子节点的哈夫曼树，其总节点数M为

### 八、森林

1、森林有e条边、k个节点，则这个森林包含k-e个树（同无向图）

2、将森林F转换为对应的二叉树T，F中的叶子节点个数等于T中左孩子为空的节点个数（画图就很清楚）

3、F是一个森林，B是由F转换的二叉树，若F中有n个非终端节点，则B的右指针域为空的节点是：n+1（建议画图）

### 九、森林转与二叉树的转换

1、本质：**左孩子，右兄弟**

2、森林转换为二叉树

![](dataStruct\森林转二叉树.png)

3、树转二叉树

<img src="dataStruct\树转二叉树.png" style="zoom:57%;" />

### 十、线索二叉树

1、线索二叉树分为先序/中序/后序线索二叉树；

2、N个节点的线索二叉树，若用二叉链表表示，有N-1个链域不为空，因而有N+1个链域为空

3、写线索二叉树应先写先序、中序、后序遍历，然后根据图，**将所以缺省的孩子变成线索**，连接遍历排序最近的节点

- D元素左右孩子都是空的，所以应连接B，A
- B元素左孩子是空的，但中序左边是空，所以没有线索
- 若某个节点线索没有指向，应指向NULL

<img src="dataStruct/v2-890ef1e99682f6ce51523ea9463a481d_r.jpg" style="zoom:20%;" />

4、线索二叉树的孩子节点标识为：

- 0 为孩子节点，例：p->rtag==0
- 1 为线索节点，例：p->rtag==1

### 二叉树计算题

1、已知完全二叉树共M个节点或哈夫曼树共M个节点，求叶子节点$n_0$的个数

- 原理：因为完全二叉树只有$n_0,n_2$,设叶子节点总个数为$n_0,则n_2=n_0-1$ 
- 若M不是2个倍数$M=n_0+n_0-1=2n_0-1$，则$n_0=\frac{M+1}{2}$ 
- 若M是2的倍数$M=n_0+n_0-1+1=2n_0$，则$n_0=\frac{M}{2}$ 

2、已知n个叶子节点的完全二叉树，其总节点数M为

- 完全二叉树含有度为1的节点

  注意由于完全二叉树的特性$n_1$ 只能为1

  $M=n_0+n_1+n_2=n_0+1+(n_0-1)$

  所以$M=2n_0$ 

- 完全二叉树的度全为2或哈夫曼树（默认情况）

  由公式$n_0=n_2+1$ 得 $n_2=n_0-1$ 

  $M=n_0+n_2$ （只有$n_0与n_2$ 的节点）

  所以$M=n_0+n_0-1=2n_0-1$ 

3、知道度为1的节点数，度为2的节点数，……，度为m的节点数，求叶子节点的个数 / 求度为0的节点个数

- 公式：$n_0=1+n_2+2n_3+3n_4+....+(m-1)n_m$ 
- 注意：$n_m$代表**度**为m的**节点个数**
- 注意：由公式可以看出 $n_1$ 节点个数不重要
- 例：$n_2$是度为2的**节点个数**

4、例题：计算第6层有8个节点的完全二叉树有多少节点

- 情况一，第6层全是叶子节点
  1. 计算前5层节点数：$2^5-1=A$
  2. 第6层节点数：8（由题目得）
  3. 前五层+第6层：A+8
- 情况二，第6层是倒数第2层，共有7层（也可说最多有多少节点）
  1. 先计算第6层一共有多少节点：$2^{6-1} = 32$
  2. 计算第6层有多少节点是含有叶子节点的：$32-8 = 24$
  3. 计算叶子节点个数，第7层节点个数：$24\times2 = 48$
  4. 计算前6层共多少节点：$2^6-1 = 63$
  5. 计算一共有多少节点 ：$48 + 63 = 111$ 

5、已知二叉树的叶子节点为$n_0$，仅有一个孩子节点个数为$n_1$，求总节点数M

- 原理：N就是$n_1$ ，M=$n_0+n_1+n_2$ ；其中$n_2=n_0-1$ ；

  所以M=$n_0+n_1+n_0-1=2n_0-1+n_1$ 

6、已知一棵有n个节点的树，其叶子节点个数为x，求该树对应二叉树中**无右孩子**结点个数：n-x+1

## 图

### 一、完全图/强连通图/连通图

1、图的定义（了解）

- 简单图：不存在重复的边，不存在从自己到自己的边

- 完全图：简单图，任意2点之间只有一条边连接

- 有向/无向图：有方向/无方向的图，表示方法：<a,b> （a,b）

- 无向无环/ 无线有环图：

  <img src="dataStruct\有环无环图.png" style="zoom:50%;" />

- 有向有环图 / 无向无环图：

  

  <img src="dataStruct\有向有环无环图.png" style="zoom:75%;" />

- 连通图：从一个点可以到达任意一点，任意两点都连通

- 强连通图：若任意两个顶点 A 和 B，满足从 A 到 B 以及从 B 到 A 都连通，也就是都含有至少一条通路，则称此有向图为强连通图

### 二、图常用公式

1、n个顶点的无向连通图，其生成树的边数：n-1

2、n个顶点n条边的**连通图**一定有环，n个顶点的**连通图（完全图）**至少要有n-1条边。

3、**无向**完全图（连通图边数最多、任意两点之间有边），节点n与边的公式：$边=\frac{(n-1)n}{2}$ 

4、**有向**完全图，节点n与边的公式：$边=(n-1)n$ 

5、n个顶点的**有向图**，每个顶点最大度（出度+入度）符合公式：2(n-1)

6、无向图G=（V，E）中含有7个节点，要保证图G任何情况都是连通的，则边数最少为？

- 思路：无向完全图必然连通（任意2点之间有边），只要6个节点是无向完全图，再加1条连接最后一个顶点的边即可
- 计算：$\frac{n(n-1)}{2} + 1 = \frac{6*5}{2} +1 = 16$

7、无向完全图**边与度**（出度+入度）的关系：2\*所有边=所以顶点的出度与入度之和

8、利用有向无环图来描述**表达式**的时候，至少需要**元素个数（不重复的）+运算符个数（不重复，乘法会被隐藏）** 

9、对于含有n个顶点的带权连通图，他的最小生成树是指图中任意一个由n个顶点构成的边的权值之和和最小的连通子图

### 三、图的遍历

1、图没有根节点，可以从任意一个顶点开始遍历

2、遍历特点：

- 广度优先遍历（BFS）是借用**队列**来存储的过程

  1. 访问一个顶点，这个顶点入队
  2. 出队一个顶点，将这个顶点能到的顶点，依次入队
  3. 以访问过的顶点，不在访问。

- 深度优先遍历（DFS）算法是递归算法，需要借助一个递归工作**栈**，故它的空问复杂度为O(V）。

  深度优先遍历，从一个点出发，一直到最后一个点，如果还有未遍历的点，则**退回**最近的分叉点进行遍历

3、邻接矩阵得到的遍历序列是唯一得，邻接表得到得遍历序列是不唯一的

### 四、图的遍历生成树

<img src="dataStruct/g01.png" style="zoom:50%;" />

1、遍历过程的记录就是生成树；图的深度优先遍历和广度优先遍历都是不唯一的

2、广度优先生遍历成树

- 将邻接矩阵、邻接表（邻接表转换为图不唯一）转换为图，再进行广度优先遍历

- 设由点A开始

  A点可到BCD，C点可到E，可得生成树（没有CD边，DE边）

  <img src="dataStruct/g02.png" style="zoom:50%;" />

3、深度优先遍历生成树

- 将邻接矩阵、邻接表（邻接表转换为图不唯一）转换为图，再进行深度优先遍历
- 访问过的点不在访问

### 四、邻接矩阵

1、邻接矩阵

- 无向图的邻接矩阵一定是对称的，有向图不一定。

- 邻接矩阵只有上/下三角，则一定是有向图无环图。

- 邻接矩阵全为1（任意2点之间都有边），完全图

- 使用邻接矩阵存储n个顶点e条边的的**无向图**，0元素的个数为
  $$
  （n^2表示总个数，2e表示总边数）无向图0元素个数=n^2-2e
  \\
  例：含有5个顶点和6条边的无向图的邻接表总，0元素的个数为
  $$
  
- 邻接矩阵有奇数个边，这是有向图；

- 无向图都要存2个边（2e），不论是邻接矩阵还是邻接表

2、邻接**矩阵**存储特点

- 因为邻接矩阵只存储节点v

$$
有向图/无向图：\\
深度优先遍历（DFS）:O(v^2)\\
广度优先遍历（BFS）:O(|v|^2)
$$

- 用**邻接矩阵**构造图时，若存储的是一个无向图，则时间复杂度为：$O(n^2 + n*e)$ 
- 邻接矩阵存储 稠密图

3、邻接矩阵的 **行** 是**出度**， **列**是**入度**；i顶点的入度 = i列非无穷且非0的元素个数之和

### 五、邻接表

1、**邻接表**存储特点

- 由于邻接表同时存储节点v和边e

$$
有向图/无向图：\\
深度优先遍历（DFS）:O(|v|+|e|)\\
广度优先遍历（BFS）:O(v+e)
$$

- 对于有v个顶点e条边的**无向图**，邻接表共存储有v个顶点2e条边
- 对于有v个顶点e条边的**有向图**，邻接表共存储有v个顶点e条边
- 显然对于**稀疏图**，**邻接表**更节省存储空间
- 无向图都要存2个边（2e），不论是邻接矩阵还是邻接表

2、邻接表组成的图，不唯一

### 六、拓扑排序AOV

1、拓扑排序一定不唯一

2、拓扑排序是**有向无环图**，有向无环图一定存在拓扑排序

### 七、关键路径AOE

1、概念：

- 关键路径：从起点到终点最长的路径（整个工期所完成的最短时间）
- 关键活动：关键路径上的活动（工期）

2、关键路径求法（事件=顶点）

<img src="dataStruct\关键路径题目.png" style="zoom:75%;" />

- 事件**最早**发生时间

  1. 当一个顶点有多个不同的入度，选择入度**数值大的数** 

     例如：2有2个入度，A：$1\to3\to2$ ，B：$1\to2$ 

     A的总长度为12，B的总长度为3，所以选择A路径

  2. 当一个顶点有多个入度，需要删除不需要的入度

     例如：当选择A路径时，删除掉不需要的路径B（a=3这条边）

  | v1   | v2    | v3   | v4   | v5   | v6   |
  | ---- | ----- | ---- | ---- | ---- | ---- |
  | 0    | ~~3~~ | 8    | 21   | 18   | 27   |
  |      | 12    |      |      | 18   | 27   |

- 确定关键路径（关键路径可能不唯一）；因为已经去掉了a=3这条边，剩下的全是关键路径（路径最短）

  1. $1\to 3\to2\to4\to6$ （8+4+9+6=27） 
  2. $1\to3\to2\to5\to6$ （8+4+6+9=27）
  3. $1\to3\to5\to6$ （8+10+9=27）

- 事件**最晚**发生时间

  1. 从终点起步，依次减去边的权值

  2. 若有当前顶点有多个出度，选择权值计算后**数值小**的一个

     例如：$v_1有2个出度,v_1\to v_2:12-3=9和v_1\to v_3:8-8=0$，所以选择$v_1\to v_3$这条边的数值

  | v1                     | v2         | v3         | v4      | v5      | v6   |
  | ---------------------- | ---------- | ---------- | ------- | ------- | ---- |
  | v3:8-8=0（选数值小的） | v4:21-9=12 | v5:18-10=8 | 27-6=21 | 27-9=18 | 27   |
  | v2:12-3=9              | v5:18-6=12 | v2:12-4=8  |         |         |      |

- 缩短工期的方法

  1. 由关键路径可以看出缩短路径d可以控制2个a、b
  2. 缩短路径f可以控制c
  3. 缩短路径b可以控制a、b、c

3、活动发生时间（边）

- 最早：事件**最早**开始时间（$A \to B$：A的最早开始时间）
- 最晚：事件**最迟**开始时间-边的权值

4、关键路径的性质

- 缩短关键路径（时间）不能缩短整体时间，只能让其他路径变成关键路径
- 增加关键路径长度（时间）会增加整体时间

### 八、最小生成树

1、最小生成树一定是最小的（代价唯一），但样子可能不同

2、最小生成树**不能有回路** 

3、最小生成树就2种算法：

- Prim（普里姆）算法：由顶点出发，选择权值最小的边，当有多个顶点时，从所以以连接的顶点找权值最小的边

- Kruskal（克鲁斯卡尔）算法：直接找权值最小的**边**。但是不能生成回路

  <img src="dataStruct/205237.png" style="zoom:50%;" />

- 其中$宁\iff 沪、杭\iff 沪、宁\iff 杭$这3个点形成了回路

  根据Kruskal算法，先选择权值小的边，由于$宁\iff杭$这条边是最后选中的且选中后形成回路，所以这条边废弃

### 九、最短路径

1、单源路径最短路径Dijkstra

<img src="dataStruct/144812.png" style="zoom:33%;" />

- 第一步画表

  $$
  \begin{array}{c|c}
      \text{节点}&状态 & 路径长度 & 前面的点\\
      \hline
     0 &\surd&0 & -\\
     1&&\infty &\\
     2&&\infty &\\
     3&&\infty &\\
     4&&\infty &\\
     5&&\infty &\\
     6&&\infty &\\
     7&&\infty &\\
     8&&\infty &\\
  \end{array}
  $$
  
- 第二步更新节点

  1. 根据图像更可到达的节点（注意，这里是带$\surd$号能到达的所有点）
  2. 路径长度更新：
     1. 0节点可以到达1和7，更新1节点和7节点的路径长度
     2. 若到某个节点有多条路径，选择数值小的路径更新（0->1路径，路径长度4小于无穷，更新成4）
     3. 注意路径长度是累加的
  3. 前面节点更新：1和7节点的前面节点都是0（都是通过0到达）
  4. 更新状态：在没有对号的专栏下，寻找路径长度最小的，打对号（最小节点为1，0->1的路径长度为4，最小）

  $$
  \begin{array}{c|c}
      \text{节点}&状态 & 路径长度& 前面的点\\
      \hline
     0 &\surd &0 & -\\
     1&\surd &4 &0\\
     2&&\infty &\\
     3&&\infty &\\
     4&&\infty &\\
     5&&\infty &\\
     6&&\infty &\\
     7&&8 &0\\
     8&&\infty &\\
  \end{array}
  $$

- 循环第二步，更新所有节点

  
  $$
  \begin{array}{c|c}
      \text{节点}&状态 & 路径长度& 前面的点\\
      \hline
     0 &\surd &0 & -\\
     1&\surd &4 &0\\
     2&\surd &12 &1\\
     3&\surd&19 &2\\
     4&\surd&21 &5\\
     5&\surd&11 &6\\
     6&\surd &9 &7\\
     7&\surd&8 &0\\
     8&\surd&14 &2\\
  \end{array}
  $$

- 得出最短路径：从最后一个节点开始，找他的前面节点

  $4\to 5\to6\to7\to 0$

2、最短路径与最短路径得目标顶点不同：弗洛伊德算法

- 弗洛伊德的算法：$O_{(n^3)}$ 

### 十、十字链表（有向图）

1、十字链表的结构

- 顶点结构：key $\fbox{data|顶点的入度|顶点的出度}$ 

  例子：顶点$v_1$ 表示为：0 $\fbox{v1| --> | --> }$ 

- 弧的结构：$\fbox{A|B|B点属性|A点属性}$

  A | B：表示边，图像中 $A\to B$ 的边

  B：B点的入度也连接到这格属性。

  B点属性：若B点有多条入度，由这个属性表示入度的连接。

  A点属性：若A点有多个出度，右这个属性表示出度的连接，

- 图中有几条连线，就有几条弧

<img src="dataStruct/171015.png" style="zoom:60%;" />

### 十一、邻接多重表（无向图）

1、邻接多重表结构

- 顶点结构：key $\fbox{data|连接的边}$ 

- 弧的结构：$\fbox{A|A点属性|B|B点属性}$

  A B：AB之间的弧

  A点属性：若A点有多个弧，可由这个属性标识，A发出的弧，

  B点属性：若B点有多个弧，可由这个属性标识，B发出的弧

- 图中有几条连线，就有几条弧

2、连接方式：从顶点开始，连接与顶点下标相同的弧

<img src="dataStruct/172516.png" style="zoom:50%;" />

## 查找

1、静态查找与动态查找

- 静态查找只查询；
- 动态查找包含插入删除查询等操作；

2、静态链表：可以线性查找，又可快速增加删除元素

### 一、顺序查找

1、线性查找 = 顺序查找；存储方式可以是顺序存储，也可以是链式存储。

2、查找失败的比较次数：n+1次

3、顺序查找（顺序结构或链式结构）的时间复杂度为： $O_{(n)}$

### 二、顺序查找ASL计算

1、n个元素，查找方式为从头扫到尾，找到待查找元素即查找成功，若到尾部没有找到，说明查找失败。

-  $ASL_{成功} = \frac{(1+2+3+…+n)}{n}  =\frac{(n+1)}{2}$ 
- $ASL_{失败} = n $ 

### 三、折半查找

1、折半查找（二分查找） $\iff$ 最佳二叉排序树 $\iff$ 折半查找判定树；

2、折半查找数据元素必须有序且是顺序存储结构（要求随机读取）

3、折半查找判断树

- 本质就是利用折半查找算法，每一个计算出来的值都是根节点

- 其中序序列是有序的（可以判别谁是折半查找判定树）

- 左子树一定小于右子树

- 查找失败 / 成功的比较次数就是元素的层数

  <img src="dataStruct/20210526192711862%20-%20%E5%89%AF%E6%9C%AC.jpg" alt="image-20221115150934553" style="zoom:50%;" />

4、折半查找mid的计算方法

``` c
//中点
int mid; //mid是int类型，所以小数点之后的会舍去
mid = （low+high）/ 2
    
//左子树,右子树一定要+1,-1不然中点计算会错误
high = mid-1
low = mid+1
```

4、折半查找最高比较次数 $\iff$ 二叉树的树高（$log_2n$）

5、例题：{1,3,9,12,32,41,45,62,75,77,82,95,100}生成的折半查找判定树为

- 下标从0开始和从1开始结果一样，本次选用从0开始

  | 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 元素 | 1    | 3    | 9    | 12   | 32   | 41   | 45   | 62   | 75   | 77   | 82   | 95   | 100  |

- 计算查找次数

  (0+12) / 2 = 6 （第一个元素下标为6，元素45）

  (0+5) / 2 = 2.5->2（因为是int型，所以舍弃小数部分）

  ……

- 画出图像

  

### 四、折半查找ASL计算

例：给11个数据元素有序表（2,3,10,15,20,25,28,29,30,35,40）采用折半查找。则ASL成功和不成功分别是多少？

1、生成折半查找判定树

<img src="dataStruct/20210526192711862.jpg" style="zoom:30%;" />

2、成功ASL计算

- 公式：（层数 * 成功的节点 之和）/ 总节点数

  1层1个；2层2个；3层4个；4层4个

  $ASL_{成功}=\frac{(1 \times 1+2\times 2+3\times 4+4\times 4)}{11}$

3、失败ASL计算

- 公式（方块）：（层数 * 失败的节点 之和）/ 总节点数

  4层4个；5层8个；

  $ASL_{失败}=\frac{4\times 4+5\times 8}{11}$

### 五、分块查找

1. 分块查找-块内可无序（块内顺序查找）

2. 分块查找-块间有序（块间用折半查找）

3. 分块查找最理想的块长（共N个元素）：$\sqrt{n}$
   
4. 索引顺序结构 $\to$ 使用分块查找快

   * 先建立分块（索引表）
   * 块间进行折半查找
   * 块内顺序查找

### 六、散列函数/哈希表

1、常见的散列方法

- 线性探测法（线性探测再散列法）：发生冲突，直接查找下一个

- 二次探测再散列法：（H（key）+d）% m；d为$1^2,-1^2,2^2,-2^2,3^2,-3^2……$ 

- 链地址（拉链法）：利用邻接表存储数据，无堆积现象

- 除留余数法：

  取关键字被某个不大于散列表长度 m 的数 P，用P求余，得到的作为散列地址。即 H(key) = key % p, p < m。 

- 直接定址法：

  取关键字或关键字的某个**线性函数值**为散列地址，常用的是：H(key) = f(key)

2、假设有K个关键字，互为同义词，线性探测法至少要探测:
$$
1+2+3+...+n = \sum_{n=1}^{n}{n}=\frac{n(n+1)}{2}
$$
3、N个元素 散列表 进行查找，**平均查找长度**不直接依赖于n（表中的记录个数）或者散列表长度

4、散列表**平均查找长度**受填装因子、堆积现象的影响

- 填装因子表示：表的满的程度（空间利用率），越大冲突越多
- 堆积不影响存储效率、散列函数、填装因子

5、散列表查找时间复杂度：0(1)

6、冲突不可避免，任何散列函数都可能产生冲突

7、填装因子 = 元素个数 / 散列表长度（常用于计算表长）

### 七、散列表ASL计算

题目：数列（7、8、30、11、18、9、14）；散列函数：H(key) = (key*3) MOD 7；装填（载）因子为 0.7

1、**计算散列表长度**：（这里数据填装到表格中使用的是除留余数法）

- 7/ 0.7=10（元素个数/填装因子 = 散列表长度）=> key从0~9

2、**求成功的 ASL 算法**

- 计算散列值：（特别容易算错，时间充足应多算一遍）

  H(7) = (7x3) MOD 7 = 0   

  H(8) = (8x3) MOD 7 = 3            

  H(30) = (30x3)MOD 7 = 6 

  H(11) = (11x3) MOD 7 = 5       

  H(18) = (18x3) MOD 7 = 5          

  H(9) = (9x3) MOD 7 = 6         

  H(14) = (14x3) MOD 7 = 0 

|   key    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| :------: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|  value   | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |
| 比较次数 | 1    | 2    |      | 1    |      | 1    | 1    | 3    | 3    |      |

- $ASL_{成功}$公式：成功比较次数之和 / 元素个数（并不是散列表长度，也不是MOD的长度）

  注意：**比较次数从1开始计算**；所以7插入0，比较1次，14需要比较2次
  
  $ASL_{成功}$（1+2+1+1+1+3+3）/  7 = 12/7

3、**计算失败的ASL**

- 【解题的关键之处】根据哈希函数地址为MOD7，因此任何一个数经散列函数计算以后的初始地址只可能在0~6的位置 
- 查找0~6位置查找失败的查找次数为： （失败位置，查找到第一个空元素的比较次数）
  KEY0到关键字为空的地址2需要比较3次，因此查找不成功的次数为3. 
  KEY1到关键字为空的地址2需要比较2次，因此查找不成功的次数为2. 
  KEY2到关键字为空的地址2需要比较1次，因此查找不成功的次数为1. 
  KEY3到关键字为空的地址4需要比较2次，因此查找不成功的次数为2. 
  KEY4到关键字为空的地址4需要比较1次，因此查找不成功的次数为1. 
  KEY5到关键字为空的地址9，因此查找不成功的次数为5. 
  KEY6到关键字为空的地址9，因此查找不成功的次数为4. 

|   key    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| :------: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|  value   | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |
| 比较次数 | 3    | 2    | 1    | 2    | 1    | 5    | 4    |      |      |      |

- ASL失败公式：失败比较次数之和 / 元素个数（并不是散列表长度，也不是MOD的长度）

  注意：**比较次数从1开始计算**；空元素比较1次，如key（2）
  
  $ASL_{失败}$：（3+2+1+2+1+5+4）/  7

### 八、B树/B+树/B-树

1、B+树是在B树的基础上增加了2个指针，一个指向root节点，一个指向叶子节点。所以B+树可以进行顺序查找，也可以进行多路查找

- B+树是针对于操作系统的文件系统需要B树的变形
- B+树常用于操作系统的文件**索引**或者数据库的**索引**

2、2阶B树最多有2个分支（子树）= 满二叉树；3阶B树最少有2个子树 = 满二叉树

3、B树（B-树）性质（利用二叉排序树记忆）

- M阶每个节点**最多**有M个子树（二叉树排序树最大有2个子树）
- M阶一个节点**最多**含有M-1个关键字（二叉排序树每个节点只有1个关键字）
- M阶每个节点**至少**含有$\lceil M / 2 \rceil $个子树
- M阶每个节点至少有$\lceil M/2 \rceil-1$个关键字
- 所有叶子节点在同一层，且不带有信息

### 九、B树添加

1、5阶B树的创立，利用性质：

- 确定关键字个数，最多有：M-1个（5-1=4）关键字
- 叶子节点
  1. 新插入的关键字，只能在叶子节点上
  2. 每当叶子节点超过最多关键字个数时，将中间的节点上升到父节点，本身节点被分成2部分
- 根节点
  1. 根节点超过最多的关键字个数，要向上提中间的关键字

2、5阶B树创立过程

<img src="dataStruct\二叉排序树的添加.jpg" style="zoom:60%;" />

### 十、B树删除

1、5阶B树的删除，利用性质：

- 确定5阶B树每个节点最少含有关键字个数：$\lceil m / 2 \rceil -1（\lceil 5 / 2 \rceil-1=2）$ 
- 当关键字个数符合最小关键字个数，可以直接删除
- 当关键字个数不符合最小关键字个数，应找父节点借关键字（同时，父节点会找其孩子节点补充关键字）

2、5阶B树的删除过程

<img src="dataStruct\二叉排序树的删除.jpg" style="zoom:50%;" />

## 排序算法

### 一、排序特点总结<重点>

- 插入类：*直接插入排序、折半排序、希尔排序*
- 交换类：冒泡排序，快排
- 选择排序：简单选择排序、堆排序

1、内部排序（大部分都要求是顺序结构）：插入类、交换类、选择类、归并排序、基数排序

2、外部排序：多路归并、拓扑排序

3、速度比较

- 数列有序时**直接插入算法**比较次数少
- 越有序使用**冒泡、直接插入**效率越高，越乱使用**快速排序**

4、比较次数

- 元素的**比较次数**（元素移动次数）与初始状态**有关**：直接插入排序、冒泡排序、快速排序、堆、希尔
- 元素的**比较次数**与初始序列**无关**是：二路归并排序、简单选择排序、基数排序
- 比较次数应注意折半插入，折半插入算法必须有序才可以使用
- 简单选择 -- n个元素**比较次数**固定为：$\frac{n(n-1)}{2}$ 
- 冒泡、直接插入 -- n个元素**比较次数**最坏为：$\frac{n(n-1)}{2}$ ；最好情况（全有序）比较次数为n-1次
- 简单选择、直接插入 -- 在最好的情况（至少）下元素**交换次数**为：0

5、排序趟数

- 算法的**排序趟数**与初始序列**有关**的是：冒泡、快排（快点冒头）
- 直接插入排序，简单选择他们的**趟数**都是固定的：n-1趟

6、元素确定

- 每一趟都确定一个元素（最大或最小）：简单选择、冒泡、堆排序
- 只有最后一趟才能确定全部元素位置：直接插入、归并排序。
- 每趟确定中间元素：快速排序

11、**希尔、堆排序**利用随机存储，不能用链表

12、查找效率低的结构是堆，堆只能用于排序，堆的内部是无序的

13、不稳定的算法：**简单选择、希尔、快速排序、堆排序**（快选希堆）

14、稳定性：排序后与排序前相对位置不变

15、元素的**移动**次数与关键字的初始排列次序**无关**的是：基数排序

16、算法复杂度与初始状态无关的是：一堆（堆排序）乌龟（归并）选（选择排序）基（基数排序）友

| 排序方式 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度  |
| -------- | -------------- | -------------- | -------------- | ----------- |
| 快速     | $O(nlog_2(n))$ | $O(n^2)$       | $O(nlog_2(n))$ | $O(log2_n)$ |
| 归并     | $O(nlog_2(n))$ | $O(nlog_2(n))$ | $O(nlog_2(n))$ | $O(n)$      |
| 堆       | $O(nlog_2(n))$ | $O(nlog_2(n))$ | $O(nlog_2(n))$ | $O(1)$      |
| 冒泡     | $O(n^2)$       | $O(n^2)$       | $O(n)$         | $O(1)$      |
| 选择     | $O(n^2)$       | $O(n^2)$       | $O(n^2)$       | $O(1)$      |
| 插入     | $O(n^2)$       | $O(n^2)$       | $O(n)$         | $O(1)$      |
| 希尔     |                | $O(n^2)$       | $O(n)$         | $O(1)$      |

### 二、直接插入排序

1、直接插入排序特点：

- 最后一趟前不能确定所有元素位置
- 局部有序（头或尾）
- i趟排序后，头或尾有 i+1 个元素有序

### 三、希尔排序

1、希尔排序是间隔内有序，要找到所有与上一次排序位置不同的数

2、希尔排序排序特点：

- 增量选择：

  10个元素，第一次增量选择10/2，第二次增量选择5/2（必须为int类型所以为2）

- 分组/元素下标确定：（注意：数增量的时候，当前元素是0）

  增量为5，则选择元素下标为（0，5）（1，6）（2，7）为分组

  增量为2，则选择元素下标为（0，2）（1，3）（2，4）（3，5）（4，6）（5，7）

- 图例：

  <img src="dataStruct\R-C.png" style="zoom:50%;" />

### 四、冒泡排序

1、待排序序列第一个元素开始，与相邻的元素比较，较大的数交换位置

- 例如：49、38、65、97、76、13、27、49

  1. 49与38比较，49大，与38交换位置，变成

     38、***49***、65、97、76、27、49

  2. 49与65比较，65大，不交换位置，指针指向65

     38、49、***65***、97、76、27、49

### 五、简单选择排序

1、每次选择最小（或最大）的元素放到头或尾

- 例如：49、38、65、97、76、13、27、49

  第一趟：***13***、49、38、65、97、76、27、49

  第二趟：***13、27***、49、38、65、97、76、49

### 六、快速排序

1、快速排序特点：

- 第 i 趟完成时，会有 i 个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，它右边的数都比它大
- 例：3，2，5，4，7，6，9是第二趟排序，问是不是快速排序
  1. 只有9符合左小右大，不是快排
- 例：2，3，5，4，6，7，9
  1. 2，3，6，7，9都符合左小右大

2、快速排序是内部排序平均性能最好的内部排序

3、数据基本有序，快排算法的时间复杂度为$O_{n^2}$ 

### 六、堆排序

1、堆排序本质是完全二叉树，元素位置关系和二叉树位置关系相同（下标0位置不放元素）

- 大根堆：父节点>孩子节点

- 小根堆：父节点<孩子节点

- 堆的存储：（从0开始存储）

  若父节点为i，左孩子为2i+1，右孩子为2i+2

  <img src="dataStruct/213145.png" style="zoom:33%;" />

- 堆的存储：（从1开始存储）

<img src="dataStruct\二叉树关系.png" style="zoom: 50%;" />



2、小根堆中，最大关键字（value）可能存储位置是(n/2)+1~n

3、堆中插入元素、删除元素实践复杂度都为O(logn)，建堆O(n^2)，堆排序查找最坏O(nlogn)

4、基本操作：

- 下滤操作（父节点破坏堆序性）
  1. 从根节点开始，与根节点的孩子节点比较，将大（大根堆，小根堆选择小的）的数放到根节点，依次循环
- 上滤操作（叶子节点破坏堆序性）
  1. 从破坏堆序性的这3个节点开始，选择大（大根堆，小根堆选择小的）的数放到父节点，依次循环

5、插入操作：直接将新元素放到最后，再进行上滤或下滤操作

6、建堆：https://www.bilibili.com/video/BV1AF411G7cA

- 自顶而下-对应上滤操作
  1. 将新元素放到最后（按照完全二叉树的形式添加元素）
  2. 每插入1个新元素，都进行上滤操作
- 自下而上-对应下滤操作
  1. 先将所以元素写成完全二叉树形式
  2. 从最后的3个元素开始，由左向右，右下到上，进行上滤操作
  3. 注意这是个递归操作，最小的数可以递归到叶子节点

### 七、归并排序

1、N个元素进行K路归并，趟数m满足公式：
$$
K^m=N -/或者/- m=\lceil\log_kN\rceil
$$
2、**外部排序**处理大文件，外部排序首选归并算法

3、将2个表（个数都为N）合并成有序表，最少（最好）比较次数为N（两个表是连续的）；最多比较2N-1次

4、二路归并算法特点：

- 第1次每连续的2个元素有序
- 第2次每连续的4个元素有序
- 第3次每连续的8个元素有序
- 第i趟有2^i个连续的元素有序

### 八、基数排序

1、原则：

- 从右向左，依次对每一位进行排序（个位、十位、百位、千位）
- 基数排序是稳定排序

