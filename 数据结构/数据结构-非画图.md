# 数据结构

## 概论

名词解释：

1. 数据：信息的载体
2. 数据元素：数据的基本单位
3. 数据对象：数据元素的集合
4. 数据类型：原子、结构、抽象数据类型（可定义完整数据结构）
5. 逻辑结构：队列、栈、串、数组、树、图、有序表。
6. 存储结构：顺序结构（循环队列）、链式（所有的链表）、索引、散列（哈希表）

时间复杂度计算：https://www.bilibili.com/video/BV1vq4y1o7Y3

## 线性表

1. 单链表必须在当前指针之后插入
2. 双链表可以在元素前后插入
3. 单向循环链表，头插/尾插的时候，知道尾节点更快
4. 双向循环链表，头插，知道尾指针效率高
5. 双向循环链表，尾插，知道头尾指针效率一样

## 队列/栈

1. 队列：**头出队，尾入队**
2. 循环队列
   * 开始：Q.rear = Q.front = 0
   * 入队：Q.rear = (Q.rear+1) % MaxSize
   * 出队：Q.front= (Q.front+1) % MaxSize
   * 队中元素个数：(Q.rear+MaxSize-Q.front) % MaxSize
3. 循环队列判断队空（牺牲一个数据大小）
   * 队满：(Q.rear+1) %MaxSize == Q.front
   * 队空：Q.rear == Q.front
4. 缓冲区利用了队列技术

## 串

KMP算法

- next数组：https://www.bilibili.com/video/BV1g341147vQ

- nextval数组：https://www.bilibili.com/video/BV1uJ411s7br
  $$
  j=1：nextval[j] = 0
  $$

  $$
  j>1:若P_j\neq P_{next[j]}\rightarrow nextval[j] = next[j] (next的值直接下移)
  $$

  $$
  j>1:若P_j=P_{next[j]} \rightarrow nextval[j] = nextval[next[j]]
  $$

## 树与二叉树

1、常用性质

- 总结节点数 = 分子数 + 1

- 度为0（叶子节点）的个数 = 度为2的节点个数 + 1
  $$
  n_0 = n_2 + 1
  \\
  n_2 = n_0 - 1
  $$

- 第i层最多有m个节点，公式：
  $$
  m = 2^{i-1}
  $$

- 高度为K的树，整个树最多有m个节点，最少拥有N个节点
  $$
  最多节点数:m=2^k-1 
  \\
  最少节点数:N=2^{k-1}
  $$

- 完全二叉树与满二叉树节点关系

  <img src="D:\moon\数据结构\image\二叉树关系.png" style="zoom:73%;" />

  

- n个节点的完全二叉树树高
  $$
  当n能被log整解:\lfloor \log_2n \rfloor + 1
  \\
  当n不能被log整解:\lceil \log_2(n+1) \rceil
  $$

2、树的遍历

- 将树转换为二叉树，再进行遍历
- 树的先序遍历（深度优先遍历） = 二叉树的先序遍历
- 树的后序遍历 = 二叉树的中序遍历
- 树的广度优先遍历 = 二叉树的层次遍历

3、前中后遍历与节点关系

- 空树、只有根节点 :left_right_arrow: 前后、前中、中后相同
- 只有一半孩子节点
  1. 左孩子为空（只有右孩子）:left_right_arrow: 前中相同（记忆：头中相同，画图）
  2. 右孩子为空（只有左孩子）:left_right_arrow: 后中相同（记忆：尾中相同，画图）
- 高度与节点数相同 :left_right_arrow: 前后相反
- 任意节点不能同时拥有左右孩子:left_right_arrow: 前中相反
- 任意节点没有左孩子:left_right_arrow: 中后相反

### 计算题

1、完全二叉树共M个节点，求叶子节点
$$
因为完全二叉树只有n_0,n_2,设叶子节点总个数为n_0,则n_2=n_0-1
\\
M为2的倍数\rightarrow M=n_0+n_0-1=2n_0-1
\\
M不是2的倍数\rightarrow M=n_0+n_0-1+1=2n_0
$$
2、M叉树，求叶子节点的个数
$$
n_0=1+n_2+2n_3+3n_4+....+(m-1)n_m
\\
注意:n_m代表度为m的节点个数,例n_2是度为2的节点个数
\\
而且不计算度为1的节点个数
$$
3、例题：计算第6层有8个节点的完全二叉树有多少节点

- 情况一，第6层全是叶子节点
  $$
  计算前5层节点数+第6层节点数
  \\
  2^5-1 + 8 =
  $$

- 情况二，第6层是倒数第2层，共有7层（也可说最多有多少节点）
  $$
  1、先计算第6层一共有多少节点 \\
  2^{6-1} = 32 \\
  2、计算第6层有多少节点是含有叶子节点的 \\
  32-8 = 24 \\
  3、计算叶子节点个数，第7层节点个数 \\
  24\times2 = 48 \\
  4、计算前6层共多少节点 \\
  2^6-1 = 63 \\
  5、计算一共有多少节点 \\
  48 + 63 = 111
  $$



## 图（填空选择）

### 一、完全图/强连通图/连通图

1、图的定义

- 完全图：任意2点之间有一条边连接
- 有向/无向图：有方向/无方向的**完全图**
- 简单图：不存在重复的边，不存在从自己到自己的边
- 连通图：从一个点可以到达任意一点
- 强连通图：若任意两个顶点 A 和 B，满足从 A 到 B 以及从 B 到 A 都连通，也就是都含有至少一条通路，则称此有向图为强连通图

2、n个顶点n条边的连通图一定有环，连通图至少要有n-1条变

3、有向完全图，顶点n与边的关系：
$$
边=(n-1)n
$$
4、无向完全图，顶点n与边的关系：
$$
边=\frac{(n-1)n}{2}
$$
5、n个顶点，则生成树有n-1条边

6、n个顶点的有向图，每个顶点最大度（出度+入度）符合公式：2(n-1)

7、n个顶点，e条边的无向图森林，有n-e个数

### 二、图与树

1、树的深度优先遍历 = 二叉树的先序遍历

2、树的广度优先遍历 = 二叉树的层次遍历

3、树的深度优先遍历输出的是逆拓扑排序（不存在回路）

4、最小生成树一定是最小的，但样子可能不同

5、最小生成树就2种算法：

- Prim算法：由点出发，寻找每个点权值最小的边。
- Kruskal算法：直接找权值最小的边。

### 三、邻接矩阵/邻接表/十字链表/多重表

1、邻接矩阵

- 无向图的邻接矩阵一定是对称的

- 有向邻接矩阵只有上/下三角，则一定无环

- 邻接矩阵全为1，则这是完全图

- 使用邻接矩阵存储n个顶点e条边的的无向图，0元素的个数为
  $$
  （n^2表示总个数，2e表示总边数）=n^2-2e
  $$

- 邻接矩阵有奇数个边，这是有向图

### 四、特别的算法

Dijkstra单源路径最短路径算法：https://www.bilibili.com/video/BV1zz4y1m7Nq?spm_id_from=333.880.my_history.page.click

## 查找

### 一、顺序查找

1、顺序查找的平均查找长度：
$$
ASL_{成功} = \frac{(1+2+3+…+n)}{n}  =\frac{(n+1)}{2}
$$
2、查找失败的比较次数：n+1次

### 二、折半查找

1、折半查找 <=> 二叉排序树 <=> 二叉排序树（可以判定谁是折半查找）

2、折半查找

+ N个元素的判定树树高：
+ 成功/失败 最多比较次数：

$$
当n能被log整解 ：\lfloor \log_2n \rfloor + 1
$$

$$
当n不能被log整解 ：\lceil \log_2(n+1) \rceil
$$

3、折半查找 失败 比较**最少**次数是：最多比较次数-1

4、二叉排序树查找性能与输入数据有关（平衡二叉树是最优解）

### 三、分块查找

1. 分块查找-块内可无序（块内顺序查找）

2. 分块查找-块间有序（块间用折半查找）

3. 分块查找最理想的块长（共N个元素）
   $$
   \sqrt{n}
   $$

4. 索引顺序结构->使用分块查找快

   * （1）先建立分块（索引表）
   * （2）块间进行折半查找
   * （3）块内顺序查找

### 四、散列函数

1、线性探测法，同义词（A mod B的余数）不一定相邻

2、假设有K个关键字，互为同义词，线性探测法至少要探测:
$$
1+2+3+...+n = \sum_{n=1}^{n}{n}=\frac{n(n+1)}{2}
$$
3、N个元素 散列表 进行查找，平均查找长度不直接依赖于n（表中的记录个数）或者散列表长度

4、散列表平均查找长度与填装因子有关

5、散列表查找时间复杂度 = 0(1)

6、填装因子表示表的满的程度，越大冲突越多

7、平均查找长度受堆积现象影响，堆积不影响存储效率、散列函数、填装因子

8、冲突不可避免，任何散列函数都可能产生冲突

9、填装因子 = 元素个数 / 散列表长度

10、散列表查找ASL

数列（7、8、30、11、18、9、14）；散列函数：H(key) = (key*3) MOD 7；装填（载）因子为0.7

（1）**计算散列表长度**：7/0.7=10（元素个数/填装因子 = 散列表长度）=> key从0~9

（2）**求成功ASL算法**

计算散列值：（特别容易算错，时间充足应多算一遍）
1. H(7) = (7x3) MOD 7 = 0   （注意：插入空元素也要比较1次）
2. H(8) = (8x3) MOD 7 = 3            
3. H(30) = (30x3)MOD 7 = 6 
4. H(11) = (11x3) MOD 7 = 5       
5. H(18) = (18x3) MOD 7 = 5          
6. H(9) = (9x3) MOD 7 = 6         
7. H(14) = (14x3) MOD 7 = 0 

|  key  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| :---: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |
|  ASL  | 1    | 2    |      | 1    |      | 1    | 1    | 3    | 3    |      |

ASL成功：成功比较次数之和 / 元素个数

ASL成功比较次数：（1+2+1+1+1+3+3）/  7 = 12/7

**（3）计算ASL失败**

【解题的关键之处】根据哈希函数地址为MOD7，因此任何一个数经散列函数计算以后的初始地址只可能在0~6的位置 
查找0~6位置查找失败的查找次数为： 
KEY0到关键字为空的地址2需要比较3次，因此查找不成功的次数为3. 
KEY1到关键字为空的地址2需要比较2次，因此查找不成功的次数为2. 
KEY2到关键字为空的地址2需要比较1次，因此查找不成功的次数为1. 
KEY3到关键字为空的地址4需要比较2次，因此查找不成功的次数为2. 
KEY4到关键字为空的地址4需要比较1次，因此查找不成功的次数为1. 
KEY5到关键字为空的地址9，因此查找不成功的次数为5. 
KEY6到关键字为空的地址9，因此查找不成功的次数为4. 
于是得到如下数据： 

|  key  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| :---: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |
| 失败  | 3    | 2    | 1    | 2    | 1    | 5    | 4    |      |      |      |

ASL失败：失败比较次数之和 / 元素个数

ASL失败：（3+2+1+2+1+5+4）/  7

### 五、B树/B+树/B-树

1、B+树是在B树的基础上增加了2个指针，一个指向root节点，一个指向叶子节点。所以B树可以进行顺序查找，也可以进行多路查找

2、B树性质

- M阶中每个节点最多有M个子树

- M阶一个节点最多含有M-1个关键字

- 除根节点之外的所有非叶子节点
  $$
  至少有\lceil m / 2 \rceil 个子树
  \\
  至少含有\lceil m/2 \rceil-1个关键字
  $$

- 所有叶子节点在同一层，且不带有信息



## 排序算法

### 一、排序特点总结

- 插入类：*直接插入排序、折半排序、希尔排序*
- 交换类：冒泡排序，快排
- 选择排序：简单选择排序、堆排序

1、内部排序（大部分都要求是顺序结构）：插入类、交换类、选择类、归并排序、基数排序

2、外部排序：多路归并、拓扑排序

3、速度比较

- 数列有序时**直接插入算法**比较次数少（效率高）
- 越有序使用 **冒泡、直接插入** 效率越高，越乱使用 **快速排序**

4、比较次数

- 直接插入排序、冒泡排序、快速排序、堆、希尔的**比较次数**（元素移动次数）与初始状态有关
- 交换类排序（冒泡，快排）**排序趟数**与初始状态有关
- 直接插入排序，简单选择排序，冒泡排序他们的**趟数**都是固定的：n-1趟

5、元素确定

- 简单选择、冒泡、堆排序，每一趟都确定一个元素（最大或最小）
- 直接插入、归并排序只有最后一趟才能确定全部元素位置。
- 快速排序每趟确定中间元素

11、希尔、堆排序利用随机存储，不能用链表

12、查找效率低的结构式堆，堆只能用于排序，堆的内部是无序的

13、不稳定的算法：简单选择、希尔、快速排序

### 二、直接插入排序

1、直接插入排序，最多（最坏）进行比较次数：（n个元素，1~(n-1)元素之和）
$$
\frac{n(n-1)}{2}
$$
2、直接插入排序特点：

- 最后一趟前不能确定所有元素位置
- 局部有序（头或尾）
- i趟排序后，头或尾有 i+1 个元素有序

### 三、希尔排序

1、希尔排序排序特点：

- 增量选择：

  10个元素，第一次增量选择10/2，第二次增量选择5/2（必须为int类型所以为2）

- 分组/元素下标确定：

  增量为5，则选择元素下标为（0，5）（1，6）（2，7）为分组

  增量为2，则选择元素下标为（0，2）（1，3）（2，4）（3，5）（4，6）（5，7）

- 图例：

  <img src="D:\moon\数据结构\image\R-C.png" style="zoom:50%;" />

### 四、冒泡排序

7、冒泡排序，全逆序的情况交换次数最多

8、冒泡排序比较次数公式（n个元素，1~(n-1)元素之和）

- 如何理解：N个数的大小并排序，第一次比较N次，第二次比较N-1次（因为每趟确定一个元素位置）……第N-1次比较1次，第N次排序完成

$$
\frac{n(n-1)}{2}
$$

### 五、快速排序

快速排序特点：每趟确定基准元素位置（一般是第一个元素）

10、快速排序是内部排序平均性能最好的内部排序

### 六、堆排序

1、堆排序本质是二叉树，元素位置关系和二叉树位置关系相同（下标0位置不放元素）

<img src="D:\moon\数据结构\image\二叉树关系.png" style="zoom: 50%;" />

2、小根堆中，最大关键字（value）可能存储位置是(n/2)+1~n

3、堆中插入元素、删除元素实践复杂度都为O(logn)，建堆O(n^2)，堆排序查找最坏O(nlogn)

4、建堆过程：https://www.bilibili.com/video/BV1AF411G7cA

### 七、归并排序

14、N个元素进行K路归并，趟数m满足公式：
$$
K^m=N -/或者/- m=\lceil\log_kN\rceil
$$
15、外部排序处理大文件，外部排序首选归并算法

16、将2个表（个数都为N）合并成有序表，最少（最好）比较次数为N（两个表是连续的）；最多比较2N-1次

17、二路归并算法特点：

- 第1次每连续的2个元素有序
- 第2次每连续的4个元素有序
- 第3次每连续的8个元素有序
- 第i趟有2^i个连续的元素有序

