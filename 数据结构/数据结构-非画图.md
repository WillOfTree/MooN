# 数据结构

## 概论

### 一、名词解释：

1. 数据：信息的载体
2. 数据元素：数据的基本单位
3. 数据对象：数据元素的集合
4. 数据类型：原子、结构、抽象数据类型（可定义完整数据结构）
5. 逻辑结构：队列、栈、串、数组、树、图、有序表。
6. 存储结构：顺序结构（循环队列）、链式（所有的链表）、索引、散列（哈希表）

### 二、时间复杂度计算

1、利用对数计算的时间复杂度（所有可以改写成while循环）

```c
// 例题：
void func(int n)
{
    int i;
    while(i<n)
    {
        i=i*2;
    }
}
```

- 根据while循环写出公式，注意i的初始值

| 次数k           | 1    | 2    | 3    | 4    | 5    |
| :-------------- | ---- | ---- | ---- | ---- | ---- |
| i的值           | 1    | 2    | 4    | 8    | 16   |
| 循环主体的值i*2 | 2    | 4    | 8    | 16   | 32   |

- 根据循环主体得到i与n的关系式：$2^k=n$
- 求得次数K关系式：$K=\log_2n$

2、for嵌套循环的时间复杂度

``` c
for(i=1;i<=n;i++)
{
    for(j=1;j<=2*i;j++)
    {
        m++;
    }
}
```

- 原则：有几个for就有几个累加，又因为m++就执行1次，所有m++为1
- 得公式：$\sum_{i=1}^n\sum_{i=1}^{2*i}1$
- 计算方法，由右向左计算
  1. n个1相加等于n，i个1相加等于i；
  2. $\sum_{i=1}^{2i}1=1+1+1+...+1=2i$ （共累加2i次，每次都加1）
  3. $\sum_{i=1}^n2i=2\sum_{i=1}^ni=1+2+3+4+...+n=2\frac{n(n+1)}{2}=n^2+2$
- 因为时间复杂度只求近似值，所以时间复杂度为$O({n^2})$

3、复杂的嵌套循环

- 超多的简单for循环

  1. 时间复杂度只是粗略计算，因此只关心**高阶**

  2. $\sum_{i=1}^n(i^2+i)=\sum_{i=1}^ni^2+\sum_{i=1}^ni；\sum_{i=1}^ni可以舍去$

  3. $1^2+2^2+3^2+...+n^2=\frac{n(n+1)(2n+1)}{6}$

  4. ``` c
     for(k=1;k<=n;k*=2)
     // 等价于
     k=1;
     while(k<=n)
         k*=2;
     ```

- 更复杂的for循环

  ``` c
  int count=0;
  for(k=1;k<=n;k*=2){
      for(j=1;j<=n;j++){
          count++;
      }
  }
  ```

  1. 最外层显然可以写成while的方式，使用对数求法
  2. 内层直接使用累加方式
  3. 将2次的时间复杂度相乘

4、递归时间复杂度

## 线性表

### 一、顺序存储-顺序表

### 二、链式存储

1、单链表必须在当前指针之后插入

2、双链表可以在元素前后插入

3、单向循环链表，头插/尾插的时候，知道尾节点更快

4、双向循环链表，头插，知道尾指针效率高

5、双向循环链表，尾插，知道头尾指针效率一样

6、长度为M和N得升序链表，

- 若将2个链表合并为**降序**（与原来的次序相反），则最坏的时间复杂度max(M,N)

- 若将2个链表合并为升序（与原来的次序相同），则最坏的时间复杂度M*N

  <img src="D:\moon\数据结构\image\合并链表.png" style="zoom:67%;" />

## 队列/栈

### 一、队列

1、队列：**头出队，尾入队**

### 二、循环队列

1、循环队列

- front与rear初始化时指向同一个区域（题目没有说明的情况，默认队列）
- 指针A指向队头元素，指针B指向队尾元素的后一个位置（默认队列）
  1. 初始化：Q.rear = Q.front = 0
  2. 入队：Q.rear = (Q.rear+1) % MaxSize
  3. 出队：Q.front= (Q.front+1) % MaxSize
  4. 队满：Q.front==(Q.rear+1) % MaxSize
     1. 这种队满浪费了一个数据元素
  5. 队空：Q.rear == Q.front
  6. 队中元素个数：(Q.rear+MaxSize-Q.front) % MaxSize
- front指向0元素

3、队列非空时指向队头和队尾

4、缓冲区利用了队列技术

### 三、前/中/后缀表达式

- 笔算方式：

  1. **中缀**表达式转**前/后缀**，只需要加括号（依据正常计算的流程），再把符号前移/后移即可

- 利用栈：

  1. 中缀转后缀

     1. 运算符入栈，数字不入栈
     2. 当前运算符优先级>栈顶元素优先级，入栈
     4. 当前运算符优先级<=栈顶元素优先级，**先弹出栈中的元素**，当前元素才可入栈
     5. “（”直接入栈，遇见“）”出栈，而且是一直出到与之匹配的“（”
     
2. **前缀/后缀**表达式转**中缀**（需要利用栈）
  
   1. 入栈方向是从数字端开始
    
   2. 数字入栈，操作符不入栈
    
   3. 遇见操作符则出栈，出栈的**数字顺序与前/后缀中的顺序**相同（）
    
      1. 前缀可以理解为：A-B中的A是**先出栈的**
        2. 后缀可以理解为：A-B中的A是**后出栈的**
    
   4. 出栈元素＋操作符组成一个整体，再次入栈
    
      **出栈方向也符合（<--是方向）：后<--栈-->前**

### 四、栈

1、若输入序列是1，2，3，……，n

- 输出序列第一个是n，则第i个元素是n-i+1
- 输出序列第一个是i（第一个元素不是n），则第j个元素是**不确定**
- 其出栈顺序是$P_1,P_2,P_3...$，若$P_2$=3（任意数），则$P_3$**可能取到的值**得个数是n-1（只有$P_2$是确定得，其他数都可取到）

2、先序序列为abcd的不同二叉树的个数

- 这相当于问以abcd的顺序入栈，出栈的顺序有多少种
- 公式：$C_{2n}^{n}\frac{1}{n+1}$ n是元素的个数
- $C_m^n=\frac{m!}{n!(m-n)!}$
- $C_n^0=C_n^n=1$

## 串

### 一、KMP算法

- next数组：https://www.bilibili.com/video/BV1g341147vQ
- nextval数组：https://www.bilibili.com/video/BV1uJ411s7br
- 已知字符串ABAABBAA……，模式串ABAAA，则next与nextval是根据**模式串**生成的
- 注意模式串下标，一般是从1开始，若是从0开始，next要全体-1

| j（默认为1） | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串P      | a    | b    | a    | a    | b    | a    | a    | b    |
| next         | 0    | 1    | 1    | 2    | 2    | 3    | 4    | 5    |
| nextval      | 0    |      |      |      |      |      |      |      |

1、next求法

- next[1]=0，next[2]=1
- 当j=3时，j前面的字母是ab
  1. a,b没有相同的，则0+1=1
- 当j=4时，当前j前面字母时aba，（都是从左向右写）
  1. a（$j_1$）        | a  （$j_3$）    
  2. ab（$j_1,j_2$）| ba（$j_2,j_3$）
  3. 相同字符串最长的个数为1，则1+1 =2
- 当j=5时，当前j前的字母顺序为abaa
  1. a     | a
  2. ab   | aa
  3. aba | baa
  4. 相同字符串最长的个数为1，则1+1=2
- 当j=6时，当前j前面的字母为abaab
  1. a       | b 
  2. ab     | ab
  3. aba   | aab
  4. abaa | baab
  5. 相同字符串最长的个数为2，则2+1=3

2、nextval求法

- 若j=1，则nextval[1] = 0
- 若j>1（$P_j$为当前指向的字符串）
  1. $P_j\neq P_{next[j]}: nextval[j] = next[j]$   (next的值直接下移，成为nextval的值)
  2. $P_j=P_{next[j]}: nextval[j] = nextval[next[j]]$

### 二、矩阵压缩

1、对称矩阵

- 特点：只要存储对角线+上三角（或者下三角）即可，因为其他地方是一样（类似于二次型矩阵）

- 计算**矩阵**$A_{ij}$元素在一维数组中的下标（下三角$i\geq j$)

  1. 计算第i-1行一共有多少元素：

     $C = 1+2+3+...+(i-1)=\frac{(1+i-1)(i-1)}{2}=\frac{i(i-1)}{2}$

  2. 计算在第i行j个元素（这里要注意，**因为数组都是从0开始，若是对称矩阵是从1开始，还要进行-1**）

     A元素在一维数组的下标：$\frac{i(i-1)}{2}+j-1$

- 计算**矩阵**$A_{ij}$元素在一维数组中的下标（上三角$i<j$)

  1. 将下三角的ij互换即可求出结果

     故公式为：$\frac{j(j-1)}{2}+i-1$

2、三对阵

- 特点1：第一行，最后一行都是2个元素

- 特点2：除1行和最后最后一行，

  中间元素下标i行j列，i=j

  前一个元素下标i行j列，i>j

  后一个元素下标i行j列，i<j

  例：$A_{43}A_{44}A_{45}$

- 计算方法：矩阵$A_{ij}$在一维数组中的位置

  1. 计算去掉第i行和第一行一共有多少元素（注意每行4个元素）

     $C_z=3 \times (i-2)$

  2. 加上第一行的2个元素，第i行第一个元素之前一共有多少元素（包含i行第一元素）

     总数：$C_z+2$

  3. 若是中间元素，则+1，若是最后元素+2

  4. 因为数组中元素是从0开始，所以下标为总数-1

3、上下三角矩阵（剩下的全为A）

- 算法与对称矩阵相同，特殊的地方在于要有一个地方存放除上三角（下三角）之外的元素，所以是对称矩阵+1

  | 一维数组： | 0    | 1    | 2    | 3    | 4    | ...  | A    |
  | ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

- 下三角（$i\geq j$）

  矩阵存放：$\frac{i(i-1)}{2}+j-1+1$

- 上三角（$i<j$）

  矩阵存放：$\frac{j(j-1)}{2}+i-1+1$

- 最后元素A的位置

  1. 下三角n行一共有多少元素

     $1+2+3+....n=\frac{(n+1)n}{2}$

  2. 因为数组元素从0开始存放所以

     A的下标：$\frac{(n+1)n}{2}-1$

## 树与二叉树

### 一、常用基础

1、总结节点数 = 分子数 + 1

2、度为0（叶子节点）的个数 = 度为2的节点个数 + 1
$$
n_0 = n_2 + 1
\\
n_2 = n_0 - 1
$$
3、第i层最多有m个节点，公式：
$$
m = 2^{i-1}
$$
4、高度为K的树，整个树最多有m个节点，最少拥有N个节点
$$
最多节点数:m=2^k-1 
\\
最少节点数:N=2^{k-1}
$$
5、完全二叉树与满二叉树节点关系

<img src="D:\moon\数据结构\image\二叉树关系.png" style="zoom:73%;" />



6、n个节点的完全二叉树树高
$$
当n能被log整解:\lfloor \log_2n \rfloor + 1
\\
当n不能被log整解:\lceil \log_2(n+1) \rceil
$$

7、森林有e条边、k个节点，则这个森林包含k-e个树

### 二、树的遍历

1、将树转换为二叉树，再进行遍历

- 树的先序遍历（深度优先遍历） = 二叉树的先序遍历
- 树的后序遍历 = 二叉树的中序遍历
- 树的广度优先遍历 = 二叉树的层次遍历

### 三、前中后遍历与节点关系

1、概述

- 空树、只有根节点 :left_right_arrow: 前后、前中、中后相同
- 只有一半孩子节点
  1. 左孩子为空（只有右孩子）:left_right_arrow: 前中相同（记忆：头中相同，画图）
  2. 右孩子为空（只有左孩子）:left_right_arrow: 后中相同（记忆：尾中相同，画图）
- 高度与节点数相同 :left_right_arrow: 前后相反
- 任意节点不能同时拥有左右孩子:left_right_arrow: 前中相反
- 任意节点没有左孩子:left_right_arrow: 中后相反（待议）

2、先序与中序、后序与中序可以确定唯一的二叉树

- 原则1：先序确定根节点（最左边的是根节点）
- 原则2：后序确定根节点（最右边的是根节点）
- 原则3：中序根据先序/后序确定的根节点划分左右子树（位置，在根节点的左边还是右边）

3、前序后序可以确定祖先关系

- 原理1：当前序为XY，后序为YX则，X是Y的祖先
- 原理2：当前序为ABC，后序为EBA，则A是B的祖先，EC是B的孩子

### 四、最小生成树

1、最小生成树一定是最小的（代价唯一），但样子可能不同

2、最小生成树就2种算法：

- Prim算法：由点出发，寻找每个点权值最小的边。
- Kruskal算法：直接找权值最小的**边**。

### 五、二叉排序树

1、二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

- 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
- 左、右子树也分别为二叉排序树；

2、二叉排序查找路径（同折半查找关键字比较）

- 例：{95，22，91，24，94，71}能否构成二叉排序树路径
  1. 原则1：2（AB）个元素确定查找方向，查找的大数（B>A）/小数（A>B）
  2. 原则2：
     1. 确定方向为小，除查找元素外，剩下的元素都应小于A
     2. 确定方向为大，除查找元素外，剩下的元素都应大于A

- 查找元素（95，22），95>22，则剩余元素都应小于95；查找元素（22，91），22<91，则剩余元素都应大于22；（91，24），91>24，则以后的元素都应小于91，而94显然大于91所以不能构成二叉排序树路径。

### 六、平衡二叉树

1、所有非叶子节点的平衡因子均为1（平衡二叉树满足最少节点情况）

- N层的总节点数C的公式：$C_n=C_{n-1}+C_{n-2}+1$
- $共1层总节点数:C_1=1;$
- $共2层总节点数:C_2=2$

- 例：6层，所有非叶子节点的平衡因子均为1，总节点数:

<img src="D:\moon\数据结构\image\总节点数.png" style="zoom:50%;" />
$$
C_1=1\\
C_2=2\\
C_{3}=C_2+C_1+1 = 1+2+1 = 4\\
C_{4}=C_3+C_2+1 = 4+2+1 = 7 \\
C_{5}=C_4+C_3+1 = 7+4+1 = 12 \\
C_{6}=C_5+C_4+1 = 12+7+1 = 20
$$

2、平衡二叉树的调整

- 调整一步即可平衡

  1. 异侧（**需要交换位置**）

     <img src="D:\moon\数据结构\image\平衡二叉树异向.jpg" style="zoom:67%;" />

  2. 单侧

  <img src="D:\moon\数据结构\image\平衡二叉树同向.jpg" style="zoom:67%;" />

  

- 调整多步
  1. 计算个节点的平衡因子
  2. 找出平衡因子改变的3个点
  3. 将这3个点写成三角形平衡的二叉树，再将其他点重新插入到树中

### 七、赫夫曼树

1、特点：n叉树**带权**且**路径最小**

2、哈夫曼树的创建

- 每次都要选择最小的节点数

- 选择的2个最小节点之和，要重新添加进待排序数列，参与最小节点的选择

  <img src="D:\moon\数据结构\image\哈夫曼树创建.png" style="zoom:50%;" />

3、WPL计算方法

- 只计算叶子节点

- 公式：叶子节点的权值*到这个叶子节点的边的个数

  $WPL_{13,15,4}=4*5+13*3+15*3$

4、哈夫曼树编码

- 生成哈夫曼树

- 只有叶子节点才可以求编码

- 左为0，右为1

  <img src="D:\moon\数据结构\image\哈夫曼树编码.png" style="zoom:50%;" />

5、前缀编码方案，按顺序写哈夫曼树，左0右1，若每一编码都是叶子节点，则是前缀编码

6、判断是否属于哈夫曼树

- 24、10、5和24、10、7

  <img src="D:\moon\数据结构\image\哈夫曼树条件.png" style="zoom:50%;" />

### 八、森林转与二叉树的转换

1、本质：**左孩子，右兄弟**

2、森林转换为二叉树

![](D:\moon\数据结构\image\森林转二叉树.png)

3、树转二叉树

<img src="D:\moon\数据结构\image\树转二叉树.png" style="zoom:57%;" />

4、将森林F转换为对应的二叉树T，F中的叶子节点个数等于T中左孩子为空的节点个数（画图就很清楚）

### 计算题

1、完全二叉树共M个节点，求叶子节点$n_0$的个数

- 原理：因为完全二叉树只有$n_0,n_2$,设叶子节点总个数为$n_0,则n_2=n_0-1$
- 若M不是2个倍数$M=n_0+n_0-1=2n_0-1$，则$n_0=\frac{M+1}{2}$
- 若M是2的倍数$M=n_0+n_0-1+1=2n_0$，则$n_0=\frac{M}{2}$

2、Z叉树，求叶子节点的个数

- 公式：$n_0=1+n_2+2n_3+3n_4+....+(m-1)n_m$
- 注意:$n_m$代表**度**为m的**节点个数**，有公式可以看出不计算$n_1$的个数
- 例：$n_2$是度为2的**节点个数**

3、例题：计算第6层有8个节点的完全二叉树有多少节点

- 情况一，第6层全是叶子节点
  $$
  计算前5层节点数+第6层节点数
  \\
  2^5-1 + 8 =
  $$

- 情况二，第6层是倒数第2层，共有7层（也可说最多有多少节点）
  $$
  1、先计算第6层一共有多少节点 \\
  2^{6-1} = 32 \\
  2、计算第6层有多少节点是含有叶子节点的 \\
  32-8 = 24 \\
  3、计算叶子节点个数，第7层节点个数 \\
  24\times2 = 48 \\
  4、计算前6层共多少节点 \\
  2^6-1 = 63 \\
  5、计算一共有多少节点 \\
  48 + 63 = 111
  $$



## 图（填空选择）

### 一、完全图/强连通图/连通图

1、图的定义

- 简单图：不存在重复的边，不存在从自己到自己的边

- 完全图：简单图，任意2点之间只有一条边连接

- 有向/无向图：有方向/无方向的图，表示方法：<a,b>

- 无向无环/ 无线有环图：

  <img src="D:\moon\数据结构\image\有环无环图.png" style="zoom:50%;" />

- 有向有环图 / 无向无环图：

  

  <img src="D:\moon\数据结构\image\有向有环无环图.png" style="zoom:75%;" />

- 连通图：从一个点可以到达任意一点，任意两点都连通

- 强连通图：若任意两个顶点 A 和 B，满足从 A 到 B 以及从 B 到 A 都连通，也就是都含有至少一条通路，则称此有向图为强连通图

2、n个顶点n条边的连通图一定有环，连通图至少要有n-1条边

3、**有向**完全图，n与边的公式：$边=(n-1)n$

4、**无向**完全图，n与边的公式：$边=\frac{(n-1)n}{2}$

5、n个顶点，则生成树有n-1条边

6、n个顶点的**有向图**，每个顶点最大度（出度+入度）符合公式：2(n-1)

7、n个顶点，e条边的无向图森林，有n-e个数

8、n个顶点任何情况下都是连通的，至少要有n-1个顶点可组成完全图，然后再连接那个顶点

- 例：无向图G=（V，E）中含有7个节点，要保证图G任何情况都是连通的，则边数最少为？
- 无向完全图必然连通（任意2点之间有边），只要6个节点是无向完全图，再加1条连接最后一个顶点的边即可
- $\frac{n(n-1)}{2} + 1 = \frac{6*5}{2} +1 = 16$

### 二、图与树的遍历

1、树的深度优先遍历 = 二叉树的先序遍历

2、树的广度优先遍历 = 二叉树的层次遍历

3、树的深度优先遍历输出的是逆拓扑排序（不存在回路）

4、遍历特点：

- 广度优先遍历（BFS）是借用**队列**来存储的过程，分层查找，优先考虑距离出发点近的点。
- 深度优先遍历（DFS）算法是递归算法，需要借助一个递归工作**栈**，故它的空问复杂度为O(V）。

### 三、邻接矩阵

1、邻接矩阵

- 无向图的邻接矩阵一定是对称的，有向图不一定。

- 邻接矩阵只有上/下三角，则一定是有向图无环图。

- 无环图一定是拓扑排序。

- 邻接矩阵全为1（任意2点之间都有边），完全图

- 使用邻接矩阵存储n个顶点e条边的的**无向图**，0元素的个数为
  $$
  （n^2表示总个数，2e表示总边数）=n^2-2e
  $$

- 邻接矩阵有奇数个边，这是有向图

2、邻接**矩阵**存储特点

- 邻接矩阵只存储节点v

$$
有向图/无向图：\\
深度优先遍历（DFS）:O(v^2)\\
广度优先遍历（BFS）:O(|v|^2)
$$

- 用**邻接矩阵**构造图时，若存储的是一个无向图，则时间复杂度为：$O(n^2 + n*e)$

### 四、邻接表

1、**邻接表**存储特点

- 由于邻接表同时存储节点v和边e

$$
有向图/无向图：\\
深度优先遍历（DFS）:O(|v|+|e|)\\
广度优先遍历（BFS）:O(v+e)
$$

- 对于有v个顶点e条边的**无向图**，邻接表共存储有v个顶点2e条边
- 对于有v个顶点e条边的**有向图**，邻接表共存储有v个顶点e条边
- 显然对于**稀疏图**，**邻接表**更节省存储空间

### 五、拓扑排序AOV

1、拓扑排序一定不唯一

2、拓扑排序是**有向无环图**，有向无环图一定存在拓扑排序

### 六、关键路径AOE

<img src="D:\moon\数据结构\image\关键路径题目.png" style="zoom:75%;" />

1、关键路径求法

- 写出事件最早发生时间

  1. 如果有多个不同的值，选择数值大的数
  2. 删除掉不需要的点，如a=3这条边

  | v1   | v2    | v3   | v4   | v5   | v6   |
  | ---- | ----- | ---- | ---- | ---- | ---- |
  | 0    | ~~3~~ | 8    | 21   | 18   | 27   |
  |      | 12    |      |      | 18   | 27   |

- 确定关键路径（关键路径可能不唯一）；因为已经去掉了a=3这条边，剩下的全是关键路径

  1. $b\to d\to c\to g (1\to 3\to2\to4\to6)$
  2. $b\to d\to e\to h(1\to3\to2\to5\to6)$
  3. $b\to f\to h(1\to3\to5\to6)$

- 缩短工期的方法

  1. 由关键路径可以看出缩短路径d可以控制2个a、b
  2. 缩短路径f可以控制c
  3. 缩短路径b可以控制a、b、c

### 画图题

1、最短路径：<手稿>

- 单源路径最短路径Dijkstra：https://www.bilibili.com/video/BV1zz4y1m7Nq?spm_id_from=333.880.my_history.page.click
  - 最短路径与最短路径得目标顶点不同
- 弗洛伊德算法

2、十字链表（有向图）：课本P208

3、邻接多重表（无向图）：课本P208

## 查找

### 一、顺序查找

1、顺序查找的平均查找长度：
$$
ASL_{成功} = \frac{(1+2+3+…+n)}{n}  =\frac{(n+1)}{2}
$$
2、查找失败的比较次数：n+1次

### 二、折半查找

1、折半查找$\iff$二叉排序树$\iff$二叉判定树（可以判定谁是折半查找）

2、折半查找规则符合二叉排序树（折半查找中关键字比较序列===二叉排序查找路径）

3、二叉判定树，本质就是利用折半查找算法，每一个计算出来的阶段是根节点

4、折半查找，N个元素的**判定树树高** 或者 **成功/失败**最多比较次数（树高）：
$$
当n能被log整解 ：\lfloor \log_2n \rfloor + 1
$$

$$
当n不能被log整解 ：\lceil \log_2(n+1) \rceil
$$

5、折半查找 **失败** 比较**最少**次数是：最多比较次数-1

6、折半查找mid的计算方法

``` c
//中点
int mid; //mid是int类型，所以小数点之后的会舍去
mid = （low+high）/ 2
    
//左子树,右子树一定要+1,-1不然中点计算会错误
high = mid-1
low = mid+1
```

7、二叉排序树查找性能与输入数据有关（平衡二叉树是最优解）

### 三、分块查找

1. 分块查找-块内可无序（块内顺序查找）

2. 分块查找-块间有序（块间用折半查找）

3. 分块查找最理想的块长（共N个元素）：$\sqrt{n}$
   
4. 索引顺序结构 $\to$ 使用分块查找快

   * 先建立分块（索引表）
   * 块间进行折半查找
   * 块内顺序查找

### 四、散列函数

1、线性探测法，同义词（A mod B的余数）不一定相邻

2、假设有K个关键字，互为同义词，线性探测法至少要探测:
$$
1+2+3+...+n = \sum_{n=1}^{n}{n}=\frac{n(n+1)}{2}
$$
3、N个元素 散列表 进行查找，**平均查找长度**不直接依赖于n（表中的记录个数）或者散列表长度

4、散列表**平均查找长度**与填装因子有关

5、散列表查找时间复杂度 = 0(1)

6、填装因子表示表的满的程度，越大冲突越多

7、平均查找长度受**堆积现象**影响，堆积不影响存储效率、散列函数、填装因子

8、冲突不可避免，任何散列函数都可能产生冲突

9、填装因子 = 元素个数 / 散列表长度

10、散列表查找ASL

数列（7、8、30、11、18、9、14）；散列函数：H(key) = (key*3) MOD 7；装填（载）因子为0.7

（1）**计算散列表长度**：7/0.7=10（元素个数/填装因子 = 散列表长度）=> key从0~9

（2）**求成功ASL算法**

计算散列值：（特别容易算错，时间充足应多算一遍）
1. H(7) = (7x3) MOD 7 = 0   （注意：插入空元素也要比较1次）
2. H(8) = (8x3) MOD 7 = 3            
3. H(30) = (30x3)MOD 7 = 6 
4. H(11) = (11x3) MOD 7 = 5       
5. H(18) = (18x3) MOD 7 = 5          
6. H(9) = (9x3) MOD 7 = 6         
7. H(14) = (14x3) MOD 7 = 0 

|  key  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| :---: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |
|  ASL  | 1    | 2    |      | 1    |      | 1    | 1    | 3    | 3    |      |

ASL成功：成功比较次数之和 / 元素个数

ASL成功比较次数：（1+2+1+1+1+3+3）/  7 = 12/7

**（3）计算ASL失败**

【解题的关键之处】根据哈希函数地址为MOD7，因此任何一个数经散列函数计算以后的初始地址只可能在0~6的位置 
查找0~6位置查找失败的查找次数为： 
KEY0到关键字为空的地址2需要比较3次，因此查找不成功的次数为3. 
KEY1到关键字为空的地址2需要比较2次，因此查找不成功的次数为2. 
KEY2到关键字为空的地址2需要比较1次，因此查找不成功的次数为1. 
KEY3到关键字为空的地址4需要比较2次，因此查找不成功的次数为2. 
KEY4到关键字为空的地址4需要比较1次，因此查找不成功的次数为1. 
KEY5到关键字为空的地址9，因此查找不成功的次数为5. 
KEY6到关键字为空的地址9，因此查找不成功的次数为4. 
于是得到如下数据： 

|  key  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| :---: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |
| 失败  | 3    | 2    | 1    | 2    | 1    | 5    | 4    |      |      |      |

ASL失败：失败比较次数之和 / 元素个数

ASL失败：（3+2+1+2+1+5+4）/  7

### 五、B树/B+树/B-树

1、B+树是在B树的基础上增加了2个指针，一个指向root节点，一个指向叶子节点。所以B树可以进行顺序查找，也可以进行多路查找

2、m阶B树有m个分支，当m取2时就是常见的**二叉排序树**

3、B树（B-树）性质（利用二叉排序树记忆）

- 主要记子树个数，关键字不论最多还是最少情况都要-1
- M阶每个节点**最多**有M个子树（二叉树排序树最大有2个子树）
- M阶一个节点**最多**含有M-1个关键字（二叉排序树每个节点只有1个关键字）
- M阶每个节点**至少**含有$\lceil m / 2 \rceil $个子树
- M阶一个节点至少有$\lceil m/2 \rceil-1$个关键字
- 所有叶子节点在同一层，且不带有信息

4、B树只有在节点超过一个节点含有关键字最多的情况下进行分裂

- 例：高度为2的5阶B树，所含的关键字最少为5
  1. 因为只有2层，最小的情况肯定是root节点满足分裂条件，叶子节点就是分裂的节点，看B树的插入

4、B树插入删除

<img src="D:\moon\数据结构\image\二叉排序树的删除.jpg" style="zoom:50%;" />

5、B树添加

<img src="D:\moon\数据结构\image\二叉排序树的添加.jpg" style="zoom:60%;" />

## 排序算法

### 一、排序特点总结

- 插入类：*直接插入排序、折半排序、希尔排序*
- 交换类：冒泡排序，快排
- 选择排序：简单选择排序、堆排序

1、内部排序（大部分都要求是顺序结构）：插入类、交换类、选择类、归并排序、基数排序

2、外部排序：多路归并、拓扑排序

3、速度比较

- 数列有序时**直接插入算法**比较次数少（效率高）
- 越有序使用 **冒泡、直接插入** 效率越高，越乱使用 **快速排序**

4、比较次数

- 直接插入排序、冒泡排序、快速排序、堆、希尔的**比较次数**（元素移动次数）与初始状态有关
- 交换类排序（冒泡，快排）**排序趟数**与初始状态有关
- 直接插入排序，简单选择排序，冒泡排序他们的**趟数**都是固定的：n-1趟

5、元素确定

- 简单选择、冒泡、堆排序，每一趟都确定一个元素（最大或最小）
- 直接插入、归并排序只有最后一趟才能确定全部元素位置。
- 快速排序每趟确定中间元素

11、希尔、堆排序利用随机存储，不能用链表

12、查找效率低的结构式堆，堆只能用于排序，堆的内部是无序的

13、不稳定的算法：简单选择、希尔、快速排序

### 二、直接插入排序

1、直接插入排序，最多（最坏）进行比较次数：（n个元素，1~(n-1)元素之和）
$$
\frac{n(n-1)}{2}
$$
2、直接插入排序特点：

- 最后一趟前不能确定所有元素位置
- 局部有序（头或尾）
- i趟排序后，头或尾有 i+1 个元素有序

### 三、希尔排序

1、希尔排序排序特点：

- 增量选择：

  10个元素，第一次增量选择10/2，第二次增量选择5/2（必须为int类型所以为2）

- 分组/元素下标确定：（注意：数增量的时候，当前元素是0）

  增量为5，则选择元素下标为（0，5）（1，6）（2，7）为分组

  增量为2，则选择元素下标为（0，2）（1，3）（2，4）（3，5）（4，6）（5，7）

- 图例：

  <img src="D:\moon\数据结构\image\R-C.png" style="zoom:50%;" />

### 四、冒泡排序

7、冒泡排序，全逆序的情况交换次数最多

8、冒泡排序比较次数公式（n个元素，1~(n-1)元素之和）

- 如何理解：N个数的大小并排序，第一次比较N次，第二次比较N-1次（因为每趟确定一个元素位置）……第N-1次比较1次，第N次排序完成

$$
\frac{n(n-1)}{2}
$$

### 五、快速排序

1、快速排序特点：

- 每趟确定1个元素，每趟确定基准元素位置（一般是第一个元素）
- 第 i 趟完成时，会有 i 个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，它右边的数都比它大
- 例：3，2，5，4，7，6，9是第二趟排序，问是不是快速排序
  1. 只有9符合左小右大，不是快排
- 例：2，3，5，4，6，7，9
  1. 2，3，6，7，9都符合左小右大

2、快速排序是内部排序平均性能最好的内部排序

### 六、堆排序

1、堆排序本质是二叉树，元素位置关系和二叉树位置关系相同（下标0位置不放元素）

<img src="D:\moon\数据结构\image\二叉树关系.png" style="zoom: 50%;" />

2、小根堆中，最大关键字（value）可能存储位置是(n/2)+1~n

3、堆中插入元素、删除元素实践复杂度都为O(logn)，建堆O(n^2)，堆排序查找最坏O(nlogn)

4、建堆过程：https://www.bilibili.com/video/BV1AF411G7cA

- 将元素由左向右依次写入二叉树；例8，15，10，21，34，16，12
- 从最后三节点依次向前调整，只要满足父节点大于孩子节点即可

### 七、归并排序

14、N个元素进行K路归并，趟数m满足公式：
$$
K^m=N -/或者/- m=\lceil\log_kN\rceil
$$
15、**外部排序**处理大文件，外部排序首选归并算法

16、将2个表（个数都为N）合并成有序表，最少（最好）比较次数为N（两个表是连续的）；最多比较2N-1次

17、二路归并算法特点：

- 第1次每连续的2个元素有序
- 第2次每连续的4个元素有序
- 第3次每连续的8个元素有序
- 第i趟有2^i个连续的元素有序

### 八、基数排序

1、原则：

- 从右向左，依次对每一位进行排序（个位、十位、百位、千位）
- 基数排序是稳定排序

