# 数据结构

## 一、概论

名词解释：

1. 数据：信息的载体
2. 数据元素：数据的基本单位
3. 数据对象：数据元素的集合
4. 数据类型：原子、结构、抽象数据类型（可定义完整数据结构）
5. 逻辑结构：队列、栈、串、数组、树、图、有序表。
6. 存储结构：顺序结构（循环队列）、链式（所有的链表）、索引、散列（哈希表）

时间复杂度计算：https://www.bilibili.com/video/BV1vq4y1o7Y3

## 二、线性表

1. 单链表必须在当前指针之后插入
2. 双链表可以在元素前后插入
3. 单向循环链表，头插/尾插的时候，知道尾节点更快
4. 双向循环链表，头插，知道尾指针效率高
5. 双向循环链表，尾插，知道头尾指针效率一样

## 三、队列/栈

1. 队列：**头出队，尾入队**
2. 循环队列
   * 开始：Q.rear = Q.front = 0
   * 入队：Q.rear = (Q.rear+1) % MaxSize
   * 出队：Q.front= (Q.front+1) % MaxSize
   * 队中元素个数：(Q.rear+MaxSize-Q.front) % MaxSize
3. 循环队列判断队空（牺牲一个数据大小）
   * 队满：(Q.rear+1) %MaxSize == Q.front
   * 队空：Q.rear == Q.front

## 四、串

KMP算法

## 五、树与二叉树

## 六、图

## 七、查找

### 顺序查找

1、顺序查找的平均查找长度：
$$
ASL_{成功} = \frac{(1+2+3+…+n)}{n}  =\frac{(n+1)}{2}
$$
2、查找失败的比较次数：n+1次

### 折半查找

1、折半查找 <=> 二叉排序树 <=> 二叉排序树（可以判定谁是折半查找）

2、折半查找

+ N个元素的判定树树高：
+ 成功/失败 最多比较次数：

$$
当n能被log整解 ：\lfloor \log_2n \rfloor + 1
$$

$$
当n不能被log整解 ：\lceil \log_2(n+1) \rceil
$$

3、折半查找 失败 比较**最少**次数是：最多比较次数-1

4、二叉排序树查找性能与输入数据有关（平衡二叉树是最优解）

### 分块查找

1. 分块查找-块内可无序（块内顺序查找）

2. 分块查找-块间有序（块间用折半查找）

3. 分块查找最理想的块长（共N个元素）
   $$
   \sqrt{n}
   $$

4. 索引顺序结构->使用分块查找快

   * （1）先建立分块（索引表）
   * （2）块间进行折半查找
   * （3）块内顺序查找

## 八、散列函数

1、线性探测法，同义词（A mod B的余数）不一定相邻

2、假设有K个关键字，互为同义词，线性探测法至少要探测:
$$
1+2+3+...+n = \sum_{n=1}^{n}{n}=\frac{n(n+1)}{2}
$$
3、N个元素 散列表 进行查找，平均查找长度不直接依赖于n（表中的记录个数）或者散列表长度

4、散列表平均查找长度与填装因子有关

5、散列表查找时间复杂度 = 0(1)

6、填装因子表示表的满的程度，越大冲突越多

7、平均查找长度受堆积现象影响，堆积不影响存储效率、散列函数、填装因子

8、冲突不可避免，任何散列函数都可能产生冲突

## 九、排序算法

### 总结

- 插入类：*直接插入排序、折半排序、希尔排序*
- 交换类：冒泡排序，快排
- 选择排序：简单选择排序、堆排序

1、内部排序（大部分都要求四顺序结构）：插入类、交换类、选择类、归并排序、基数排序

2、外部排序：多路归并、拓扑排序

3、直接插入排序，最多（最坏）进行比较次数：（n个元素，1~(n-1)元素之和）
$$
\frac{n(n-1)}{2}
$$
4、直接插入排序，最少进行 n-1 次比较（全有序的情况）

5、直接插入排序特点：

- 最后一趟前不能确定所有元素位置
- 局部有序（头或尾）
- i趟排序后，头或尾有 i+1 个元素有序

6、希尔排序排序特点：

- 增量选择：

  10个元素，第一次增量选择10/2，第二次增量选择5/2（必须为int类型所以为2）

- 分组/元素下标确定：

  增量为5，则选择元素下标为（0，5）（1，6）（2，7）为分组

  增量为2，则选择元素下标为（0，2）（1，3）（2，4）（3，5）（4，6）（5，7）

- 图例：

  <img src="D:\moon\数据结构\image\R-C.png" style="zoom:50%;" />

7、冒泡排序，全逆序的情况交换次数最多

8、冒泡排序比较次数公式（n个元素，1~(n-1)元素之和）

- 如何理解：N个数的大小并排序，第一次比较N次，第二次比较N-1次（因为每趟确定一个元素位置）……第N-1次比较1次，第N次排序完成

$$
\frac{n(n-1)}{2}
$$

9、快速排序特点：每趟确定基准元素位置（一般是第一个元素）

10、快速排序是内部排序平均性能最好的内部排序

11、堆排序本质是二叉树，元素位置关系和二叉树位置关系相同（下标0位置不放元素）

<img src="D:\moon\数据结构\image\二叉树关系.png" style="zoom: 50%;" />

12、小根堆中，最大关键字（value）可能存储位置是(n/2)+1~n

13、堆中插入元素、删除元素实践复杂度都为O(logn)，建堆O(n^2)，堆排序查找最坏O(nlogn)

14、N个元素进行K路归并，趟数m满足公式：
$$
K^m=N -/或者/- m=\lceil\log_kN\rceil
$$
15、外部排序处理大文件，外部排序首选归并算法

16、将2个表（个数都为N）合并成有序表，最少（最好）比较次数为N（两个表是连续的）；最多比较2N-1次

17、二路归并算法特点：

- 第1次每连续的2个元素有序
- 第2次每连续的4个元素有序
- 第3次每连续的8个元素有序
- 第i趟有2^i个连续的元素有序

### 排序特点总结

1、数列有序时直接插入算法比较次数少（效率高）

2、越有序使用 **冒泡、直接插入** 效率越高，越乱使用 **快速排序**

3、直接插入排序、冒泡排序、快速排序的比较次数（元素移动次数）与初始状态有关

4、直接插入排序，简单选择排序，冒泡他们的趟数都是固定的：n-1趟

5、简单选择、冒泡、堆排序，每一趟都确定一个元素（最大或最小）

6、快速排序每趟确定中间元素

7、交换类排序（冒泡，快排）排序趟数与初始状态有关

8、直接插入、归并排序只有最后一趟才能确定全部元素位置。

9、希尔、堆排序利用随机存储，不能用链表

10、查找效率低的结构式堆，堆只能用于排序，堆的内部是无序的

11、不稳定的算法：简单选择、希尔、快速排序
